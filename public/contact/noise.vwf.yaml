extends: http://vwf.example.com/node3.vwf
properties:
  
  amount:
    value: 0
    set: |
            this.amount = value;
            this.dirtyStack();
  octaves:
    value: 256
    set: |
            this.octaves = value;
            this.dirtyStack();          
  noisescale:
    value: 1
    set: |
            this.noisescale = value;
            this.dirtyStack();
  iterations:
    value: 2
    set: |
            this.iterations = value;
            this.dirtyStack();
  phase:
    value: 0
    set: |
            this.phase = value;
            this.dirtyStack();          
  seed:
    value: 1
    set: |
            this.seed = value;
            
            this.random = this.Random(this.seed);
         
             this.permutation = [];
             for(var i =0; i < 512; i++)
             {
                this.permutation.push(Math.floor(this.random.getRandomNumber()*256));
             }         
             this.Perlin = new this.PerlinNoise(this.permutation);
            this.simplex = new SimplexNoise(this.random.getRandomNumber);
            this.dirtyStack(); 
  effectX:
    set: |
            this.effectX = value;
            this.dirtyStack();
  ComputeNormals:
    set: |
            this.ComputeNormals = value;
            this.dirtyStack();             
  effectY:
    set: |
            this.effectY = value;
            this.dirtyStack(); 
  effectZ:
    set: |
            this.effectZ = value;
            this.dirtyStack();             
  translation:
    set: |
            this.translation = value;
  rotation:
    set: |
            this.rotation = value;
  scale:
    set: |
            this.scale = value;
  WorldSpace:
    value: 0
    set: |
            this.WorldSpace = value;
            this.dirtyStack();              
  minAmount:
  maxAmount:
  isModifier: true
  type:
  EditorData:
    amount:
      displayname: noise amount
      property: amount
      type: slider
      min: 0
      max: 5
      step: .01
    noisescale:
      displayname: noise scale
      property: noisescale
      type: slider
      min: 0
      max: 1
      step: .01
    iterations:
      displayname: iterations
      property: iterations
      type: slider
      min: 2
      max: 5
      step: 1	
    octaves:
      displayname: Octaves
      property: octaves
      type: slider
      min: 8
      max: 256
      step: 1	  
    seed:
      displayname: random seed
      property: seed
      type: slider
      min: 1
      max: 512
      step: 1
    phase:
      displayname: phase
      property: phase
      type: slider
      min: 0
      max: 1
      step: .001  
    effectX:
      displayname: Effect X
      property: effectX
      type: check
    effectY:
      displayname: Effect Y
      property: effectY
      type: check 
    effectZ:
      displayname: Effect Z
      property: effectZ
      type: check
    ComputeNormals:
      displayname: Compute Normals
      property: ComputeNormals
      type: check  
    WorldSpace:
      displayname: Use World Positions
      property: WorldSpace
      type: check      
methods:
  GetBounds:
  updateStack:
  updateSelf:
  dirtyStack:
  GetMesh:
  noise:
events:
  childAdded:
scripts:
- |
    this.updateSelf = function()
    {
        
        if(this.id == 'noise-vwf')
            return;
        var scale = vwf.getProperty(this.id,'noisescale');
        var iterations = vwf.getProperty(this.id,'iterations');
        var seed = vwf.getProperty(this.id,'seed');
        
        
        if(!this.random)
        {
            
            this.random = this.Random(seed);
         
             this.permutation = [];
             for(var i =0; i < 512; i++)
             {
                this.permutation.push(Math.floor(this.random.getRandomNumber()*256));
             }         
             this.Perlin = new this.PerlinNoise(this.permutation);
            
             this.simplex = new SimplexNoise(this.random.getRandomNumber);
        
        }
        
        
        var x = vwf.getProperty(this.id,'effectX');
        var y = vwf.getProperty(this.id,'effectY');
        var z = vwf.getProperty(this.id,'effectZ');
        var world = vwf.getProperty(this.id,'WorldSpace');
        var phase = vwf.getProperty(this.id,'phase');
        
        this.noise(scale,iterations,seed,x,y,z,world,phase);
    }
    var RotateVecAroundAxis = function(Vector, Axis, Radians)
    {
        //Get a quaternion for the input matrix
        var RotationQuat = goog.vec.Quaternion.fromAngleAxis(Radians, Axis, Quat());
        var NewMatrix = goog.vec.Quaternion.toRotationMatrix4(RotationQuat, Matrix());
        return MATH.mulMat4Vec3(NewMatrix,Vector);
    }
    
    this.PerlinNoise = function(permutation) {

        this.noise = function(x, y, z,o) {

           if(!o)
            o = 256
           var p = new Array(512)
          
           for (var i=0; i < o ; i++) 
         p[o+i] = p[i] = permutation[i]; 

              var X = Math.floor(x) & 255,                  // FIND UNIT CUBE THAT
                  Y = Math.floor(y) & 255,                  // CONTAINS POINT.
                  Z = Math.floor(z) & 255;
              x -= Math.floor(x);                                // FIND RELATIVE X,Y,Z
              y -= Math.floor(y);                                // OF POINT IN CUBE.
              z -= Math.floor(z);
              var    u = fade(x),                                // COMPUTE FADE CURVES
                     v = fade(y),                                // FOR EACH OF X,Y,Z.
                     w = fade(z);
              var A = p[X  ]+Y, AA = p[A]+Z, AB = p[A+1]+Z,      // HASH COORDINATES OF
                  B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;      // THE 8 CUBE CORNERS,

              return scale(lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  // AND ADD
                                             grad(p[BA  ], x-1, y  , z   )), // BLENDED
                                     lerp(u, grad(p[AB  ], x  , y-1, z   ),  // RESULTS
                                             grad(p[BB  ], x-1, y-1, z   ))),// FROM  8
                             lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  // CORNERS
                                             grad(p[BA+1], x-1, y  , z-1 )), // OF CUBE
                                     lerp(u, grad(p[AB+1], x  , y-1, z-1 ),
                                             grad(p[BB+1], x-1, y-1, z-1 )))));
           }
           function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
           function lerp( t, a, b) { return a + t * (b - a); }
           function grad(hash, x, y, z) {
              var h = hash & 15;                      // CONVERT LO 4 BITS OF HASH CODE
              var u = h<8 ? x : y,                 // INTO 12 GRADIENT DIRECTIONS.
                     v = h<4 ? y : h==12||h==14 ? x : z;
              return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
           } 
           function scale(n) { return (1 + n)/2; }
    }
    
    this.Random = function(seed)
    {
        function Rc4Random(seed)
        {
            var keySchedule = [];
            var keySchedule_i = 0;
            var keySchedule_j = 0;
            
            function init(seed) {
                for (var i = 0; i < 256; i++)
                    keySchedule[i] = i;
                
                var j = 0;
                for (var i = 0; i < 256; i++)
                {
                    j = (j + keySchedule[i] + seed.charCodeAt(i % seed.length)) % 256;
                    
                    var t = keySchedule[i];
                    keySchedule[i] = keySchedule[j];
                    keySchedule[j] = t;
                }
            }
            init(seed);
            
            function getRandomByte() {
                keySchedule_i = (keySchedule_i + 1) % 256;
                keySchedule_j = (keySchedule_j + keySchedule[keySchedule_i]) % 256;
                
                var t = keySchedule[keySchedule_i];
                keySchedule[keySchedule_i] = keySchedule[keySchedule_j];
                keySchedule[keySchedule_j] = t;
                
                return keySchedule[(keySchedule[keySchedule_i] + keySchedule[keySchedule_j]) % 256];
            }
            
            this.getRandomNumber = function() {
                var number = 0;
                var multiplier = 1;
                for (var i = 0; i < 8; i++) {
                    number += getRandomByte() * multiplier;
                    multiplier *= 256;
                }
                return number / 18446744073709551616;
            }.bind(this);
            this.Random = this.getRandomNumber;
        }
        return new Rc4Random(seed +"");
    }
    this.getNoise= function(randarray,x,y,z,scale,iterations,phase)
    {
            
            var z =0;
           // return 10-MATH.lengthVec3([x,y,z]);
            for(var j = 1; j < iterations; j++)
            {
              
              var z1 = this.Perlin.noise((randarray[j-1]+(x+ phase))*scale*j ,
                                    (randarray[j-1]+(y+ phase))*scale*j ,
                                    (randarray[j-1]+(z+ phase))*scale*j,this.octaves );
              
        //     var z1 = this.simplex.noise3D((randarray[j-1]+(x+ phase))*scale*j ,
        //                            (randarray[j-1]+(y+ phase))*scale*j ,
        //                            (randarray[j-1]+(z+ phase))*scale*j);
              
              z1 -= .5;
              z1 /= (j);
              z += z1;
            }
            return z;
    }
    this.noise = function(scale,iterations,seed,effectX,effectY,effectZ,useWorldSpace,phase)
    {   
        
         
         
         if(this.amount == undefined) return;
         var mesh = this.GetMesh();
         if(!mesh)
            return;
         var m = mesh.geometry;
         if(!m) return;
         var positions = [];
         
         for(var i=0;i<m.vertices.length; i++)
         {
            positions.push([m.vertices[i].x,m.vertices[i].y,m.vertices[i].z]);
         }
         
         var normals = [];
         for(var i=0;i<m.faces.length; i++)
         {
            normals.push([m.faces[i].normal.x,m.faces[i].normal.y,m.faces[i].normal.z]);
         }
         
         var bounds = m.boundingBox;
         if(!bounds)
            m.computeBoundingBox();
         bounds = m.boundingBox;
         
         var height = bounds.max.z - bounds.min.z;
         var length = bounds.max.x - bounds.min.x;
         var width = bounds.max.y - bounds.min.y;
         
         //if(height == 0)
            height = 1;
         //if(width == 0)
            width = 1;
         //if(length == 0)
            length = 1;
         var amt = this.amount*6.28318530718;
         var randZ = [];
         var randY = [];
         var randX = [];
         for(var j = 1; j < iterations; j++)
         {
            randZ.push(this.permutation[0]);
            randY.push(this.permutation[1]);   
            randX.push(this.permutation[2]);               
         }
         for(var i=0;i<positions.length; i+=1)
         {
             var totalnorm = normals[i] || [0,0,0];
             var thispos = positions[i];
             if(useWorldSpace == true)
             {
                thispos = MATH.mulMat4Vec3(mesh.getModelMatrix(),thispos);
             }
             if(effectZ)
             {
                
                var z = this.getNoise(randZ,thispos[0]/length,thispos[1]/width,thispos[2]/height,scale,iterations,phase);
                var zx1 = this.getNoise(randZ,(thispos[0] +.1)/length,thispos[1]/width,thispos[2]/height,scale,iterations,phase);
                var zy1 = this.getNoise(randZ,thispos[0]/length,(thispos[1]+.1)/width,thispos[2]/height,scale,iterations,phase);
                var x1 = [positions[i][0]+.1,positions[i][1],positions[i][2]+ zx1*amt];
                var y1 = [positions[i][0],positions[i][1]+.1,positions[i][2]+ zy1*amt];
                positions[i][2] += z * amt;
                
            /*    var dx = MATH.subVec3(x1,positions[i]);
                dx = MATH.scaleVec3(dx,1/MATH.lengthVec3(dx));
                var dy = MATH.subVec3(y1,positions[i]);
                dy = MATH.scaleVec3(dy,1/MATH.lengthVec3(dy));
                var norm = MATH.crossVec3(dx,dy);
                
                norm = MATH.scaleVec3(norm,1/MATH.lengthVec3(norm));
                
                var a = MATH.crossVec3(norm,[0,0,1]);
                var tofront = goog.vec.Quaternion.createFromValues( a[0], a[1], a[2], 1 + MATH.dotVec3(norm,[0,0,1]) );  
                var  tofront_norm = [];
                
                goog.vec.Quaternion.normalize(tofront,tofront_norm);                    
                var rotmat = goog.vec.Quaternion.toRotationMatrix4 (tofront_norm,Matrix()); */
            //    if(i < normals.length)
            //    normals[i] = MATH.mulMat4Vec3(rotmat,normals[i]);
                //normals[i][1] *= -1;
                 //normals[i][0] *= -1;
             }
             if(effectX)
             {
                var x = this.getNoise(randX,thispos[0]/length,thispos[1]/width,thispos[2]/height,scale,iterations,phase);
                var xy1 = this.getNoise(randX,(thispos[0])/length,(thispos[1]+.1)/width,thispos[2]/height,scale,iterations,phase);
                var xz1 = this.getNoise(randX,thispos[0]/length,(thispos[1])/width,(thispos[2]+.1)/height,scale,iterations,phase);
                var y1 = [positions[i][0]+ xy1*amt,positions[i][1]+.1,positions[i][2]];
                var z1 = [positions[i][0]+ xz1*amt,positions[i][1],positions[i][2]+.1];
                positions[i][0] += x * amt;
                
             /*   var dy = MATH.subVec3(y1,positions[i]);
                dy = MATH.scaleVec3(dy,1/MATH.lengthVec3(dy));
                var dz = MATH.subVec3(z1,positions[i]);
                dz = MATH.scaleVec3(dz,1/MATH.lengthVec3(dz));
                var norm = MATH.crossVec3(dy,dz);
                
                norm = MATH.scaleVec3(norm,1/MATH.lengthVec3(norm));
                
                var a = MATH.crossVec3(norm,[1,0,0]);
                var tofront = goog.vec.Quaternion.createFromValues( a[0], a[1], a[2], 1 + MATH.dotVec3(norm,[1,0,0]) );  
                var  tofront_norm = [];
                
                goog.vec.Quaternion.normalize(tofront,tofront_norm);                    
                var rotmat = goog.vec.Quaternion.toRotationMatrix4 (tofront_norm,Matrix()); */
            //    if(i < normals.length)
            //    normals[i] = MATH.mulMat4Vec3(rotmat,normals[i]);
             }
             if(effectY)
             {
                var y = this.getNoise(randY,thispos[0]/length,thispos[1]/width,thispos[2]/height,scale,iterations,phase);
                var yx1 = this.getNoise(randY,(thispos[0]+.1)/length,(thispos[1])/width,thispos[2]/height,scale,iterations,phase);
                var yz1 = this.getNoise(randY,thispos[0]/length,(thispos[1])/width,(thispos[2]+.1)/height,scale,iterations,phase);
                var x1 = [positions[i][0]+.1,positions[i][1]+ yx1*amt,positions[i][2]];
                var z1 = [positions[i][0],positions[i][1]+ yz1*amt,positions[i][2]+.1];
                positions[i][1] += y * amt;
                
             /*   var dx = MATH.subVec3(x1,positions[i]);
                dx = MATH.scaleVec3(dx,1/MATH.lengthVec3(dx));
                var dz = MATH.subVec3(z1,positions[i]);
                dz = MATH.scaleVec3(dz,1/MATH.lengthVec3(dz));
                var norm = MATH.crossVec3(dz,dx);
                norm = MATH.scaleVec3(norm,1/MATH.lengthVec3(norm));
                
                var a = MATH.crossVec3(norm,[0,1,0]);
                var tofront = goog.vec.Quaternion.createFromValues( a[0], a[1], a[2], 1 + MATH.dotVec3(norm,[0,1,0]) );  
                var  tofront_norm = [];
                
                goog.vec.Quaternion.normalize(tofront,tofront_norm);                    
                var rotmat = goog.vec.Quaternion.toRotationMatrix4 (tofront_norm,Matrix());
                if(i < normals.length)
                normals[i] = MATH.mulMat4Vec3(rotmat,normals[i]); */
              }
            //  if(i < normals.length)
            //  normals[i] = MATH.scaleVec3(normals[i],1/MATH.lengthVec3(normals[i]));
         }
         
         for(var i=0;i<positions.length; i+=1)
         {
            m.vertices[i].x = (positions[i][0]);
            m.vertices[i].y = (positions[i][1]);
            m.vertices[i].z = (positions[i][2]);
         }
         
         m.verticesNeedUpdate = true;
         m.dirtyMesh = true;
        mesh.sceneManagerUpdate();

         
        /* for(var i=0;i<normals.length; i+=1)
         {
            m.faces[i].normal.x = (normals[i][0]);
            m.faces[i].normal.y = (normals[i][1]);
            m.faces[i].normal.z = (normals[i][2]);
            for(var j = 0; j < m.faces[i].vertexNormals.length; j++)
            {
                m.faces[i].vertexNormals[j].x = (normals[i][0]);
                m.faces[i].vertexNormals[j].y = (normals[i][1]);
                m.faces[i].vertexNormals[j].z = (normals[i][2]);
         }
         }
         */
         if(this.ComputeNormals)
         {
            m.computeFaceNormals();
            m.computeVertexNormals();
            m.normalsNeedUpdate = true;
         }
        
    }
    this.updateStack = function()
    {
        if(this.amount == undefined) return;
       
        this.updateSelf();
        for(var i in this.children)
        {
            return vwf.callMethod(this.children[i].id,'updateStack');
        }
    }
    this.initialize = function()
    {
         
    }
    this.GetMesh = function()
    {
        if(this.amount == undefined) return;
        return vwf.callMethod(vwf.parent(this.id),'GetMesh');
    }
    this.GetBounds = function()
    {
        if(this.amount == undefined) return;
        return vwf.callMethod(vwf.parent(this.id),'GetBounds');
    }
    this.dirtyStack = function()
    {
        if(this.amount == undefined) return;
        
        return vwf.callMethod(vwf.parent(this.id),'dirtyStack');
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    var Matrix = function()
    {
        var mat = [];
        for(var i=0; i < 16; i++)
        {
            mat.push(0);
        }
        return mat;
    }
    //quick function to initialize a blank vector array
    var Vec3 = function()
    {
        var vec = [];
        for(var i=0; i < 3; i++)
        {
            vec.push(0);
        }
        return vec;
    }
    var Quat = function()
    {
        var quat = [];
        for(var i=0; i < 4; i++)
        {
            quat.push(0);
        }
        return quat;
    };
    var RotateVecAroundAxis = function(Vector, Axis, Radians)
    {
        //Get a quaternion for the input matrix
        var RotationQuat = goog.vec.Quaternion.fromAngleAxis(Radians, Axis, Quat());
        var NewMatrix = goog.vec.Quaternion.toRotationMatrix4(RotationQuat, Matrix());
        return MATH.mulMat4Vec3(NewMatrix,Vector);
    }
    /*
     * A fast javascript implementation of simplex noise by Jonas Wagner
     *
     * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
     * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     *
     *
     * Copyright (C) 2012 Jonas Wagner
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject to
     * the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
     * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
     * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     *
     */
    

    var F2 = 0.5 * (Math.sqrt(3.0) - 1.0),
        G2 = (3.0 - Math.sqrt(3.0)) / 6.0,
        F3 = 1.0 / 3.0,
        G3 = 1.0 / 6.0,
        F4 = (Math.sqrt(5.0) - 1.0) / 4.0,
        G4 = (5.0 - Math.sqrt(5.0)) / 20.0;

    
    function SimplexNoise(random) {
        if (!random) random = Math.random;
        this.p = new Uint8Array(256);
        this.perm = new Uint8Array(512);
        this.permMod12 = new Uint8Array(512);
        for (var i = 0; i < 256; i++) {
            this.p[i] = random() * 256;
        }
        for (i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
            this.permMod12[i] = this.perm[i] % 12;
        }

    }
    window.SimplexNoise = SimplexNoise;
    SimplexNoise.prototype = {
        grad3: new Float32Array([1, 1, 0,
                                - 1, 1, 0,
                                1, - 1, 0,

                                - 1, - 1, 0,
                                1, 0, 1,
                                - 1, 0, 1,

                                1, 0, - 1,
                                - 1, 0, - 1,
                                0, 1, 1,

                                0, - 1, 1,
                                0, 1, - 1,
                                0, - 1, - 1]),
        grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, - 1, 0, 1, - 1, 1, 0, 1, - 1, - 1,
                                0, - 1, 1, 1, 0, - 1, 1, - 1, 0, - 1, - 1, 1, 0, - 1, - 1, - 1,
                                1, 0, 1, 1, 1, 0, 1, - 1, 1, 0, - 1, 1, 1, 0, - 1, - 1,
                                - 1, 0, 1, 1, - 1, 0, 1, - 1, - 1, 0, - 1, 1, - 1, 0, - 1, - 1,
                                1, 1, 0, 1, 1, 1, 0, - 1, 1, - 1, 0, 1, 1, - 1, 0, - 1,
                                - 1, 1, 0, 1, - 1, 1, 0, - 1, - 1, - 1, 0, 1, - 1, - 1, 0, - 1,
                                1, 1, 1, 0, 1, 1, - 1, 0, 1, - 1, 1, 0, 1, - 1, - 1, 0,
                                - 1, 1, 1, 0, - 1, 1, - 1, 0, - 1, - 1, 1, 0, - 1, - 1, - 1, 0]),
        noise2D: function (xin, yin) {
            var permMod12 = this.permMod12,
                perm = this.perm,
                grad3 = this.grad3;
            var n0=0, n1=0, n2=0; // Noise contributions from the three corners
            // Skew the input space to determine which simplex cell we're in
            var s = (xin + yin) * F2; // Hairy factor for 2D
            var i = Math.floor(xin + s);
            var j = Math.floor(yin + s);
            var t = (i + j) * G2;
            var X0 = i - t; // Unskew the cell origin back to (x,y) space
            var Y0 = j - t;
            var x0 = xin - X0; // The x,y distances from the cell origin
            var y0 = yin - Y0;
            // For the 2D case, the simplex shape is an equilateral triangle.
            // Determine which simplex we are in.
            var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
            if (x0 > y0) {
                i1 = 1;
                j1 = 0;
            } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
            else {
                i1 = 0;
                j1 = 1;
            } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
            // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
            // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
            // c = (3-sqrt(3))/6
            var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
            var y1 = y0 - j1 + G2;
            var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
            var y2 = y0 - 1.0 + 2.0 * G2;
            // Work out the hashed gradient indices of the three simplex corners
            var ii = i & 255;
            var jj = j & 255;
            // Calculate the contribution from the three corners
            var t0 = 0.5 - x0 * x0 - y0 * y0;
            if (t0 >= 0) {
                var gi0 = permMod12[ii + perm[jj]] * 3;
                t0 *= t0;
                n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
            }
            var t1 = 0.5 - x1 * x1 - y1 * y1;
            if (t1 >= 0) {
                var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
                t1 *= t1;
                n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
            }
            var t2 = 0.5 - x2 * x2 - y2 * y2;
            if (t2 >= 0) {
                var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
                t2 *= t2;
                n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
            }
            // Add contributions from each corner to get the final noise value.
            // The result is scaled to return values in the interval [-1,1].
            return 70.0 * (n0 + n1 + n2);
        },
        // 3D simplex noise
        noise3D: function (xin, yin, zin) {
            var permMod12 = this.permMod12,
                perm = this.perm,
                grad3 = this.grad3;
            var n0, n1, n2, n3; // Noise contributions from the four corners
            // Skew the input space to determine which simplex cell we're in
            var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
            var i = Math.floor(xin + s);
            var j = Math.floor(yin + s);
            var k = Math.floor(zin + s);
            var t = (i + j + k) * G3;
            var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
            var Y0 = j - t;
            var Z0 = k - t;
            var x0 = xin - X0; // The x,y,z distances from the cell origin
            var y0 = yin - Y0;
            var z0 = zin - Z0;
            // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
            // Determine which simplex we are in.
            var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
            var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
            if (x0 >= y0) {
                if (y0 >= z0) {
                    i1 = 1;
                    j1 = 0;
                    k1 = 0;
                    i2 = 1;
                    j2 = 1;
                    k2 = 0;
                } // X Y Z order
                else if (x0 >= z0) {
                    i1 = 1;
                    j1 = 0;
                    k1 = 0;
                    i2 = 1;
                    j2 = 0;
                    k2 = 1;
                } // X Z Y order
                else {
                    i1 = 0;
                    j1 = 0;
                    k1 = 1;
                    i2 = 1;
                    j2 = 0;
                    k2 = 1;
                } // Z X Y order
            }
            else { // x0<y0
                if (y0 < z0) {
                    i1 = 0;
                    j1 = 0;
                    k1 = 1;
                    i2 = 0;
                    j2 = 1;
                    k2 = 1;
                } // Z Y X order
                else if (x0 < z0) {
                    i1 = 0;
                    j1 = 1;
                    k1 = 0;
                    i2 = 0;
                    j2 = 1;
                    k2 = 1;
                } // Y Z X order
                else {
                    i1 = 0;
                    j1 = 1;
                    k1 = 0;
                    i2 = 1;
                    j2 = 1;
                    k2 = 0;
                } // Y X Z order
            }
            // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
            // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
            // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
            // c = 1/6.
            var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
            var y1 = y0 - j1 + G3;
            var z1 = z0 - k1 + G3;
            var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
            var y2 = y0 - j2 + 2.0 * G3;
            var z2 = z0 - k2 + 2.0 * G3;
            var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
            var y3 = y0 - 1.0 + 3.0 * G3;
            var z3 = z0 - 1.0 + 3.0 * G3;
            // Work out the hashed gradient indices of the four simplex corners
            var ii = i & 255;
            var jj = j & 255;
            var kk = k & 255;
            // Calculate the contribution from the four corners
            var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
            if (t0 < 0) n0 = 0.0;
            else {
                var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
                t0 *= t0;
                n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
            }
            var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
            if (t1 < 0) n1 = 0.0;
            else {
                var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
                t1 *= t1;
                n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
            }
            var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
            if (t2 < 0) n2 = 0.0;
            else {
                var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
                t2 *= t2;
                n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
            }
            var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
            if (t3 < 0) n3 = 0.0;
            else {
                var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
                t3 *= t3;
                n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
            }
            // Add contributions from each corner to get the final noise value.
            // The result is scaled to stay just inside [-1,1]
            return 32.0 * (n0 + n1 + n2 + n3);
        },
        // 4D simplex noise, better simplex rank ordering method 2012-03-09
        noise4D: function (x, y, z, w) {
            var permMod12 = this.permMod12,
                perm = this.perm,
                grad4 = this.grad4;

            var n0, n1, n2, n3, n4; // Noise contributions from the five corners
            // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
            var s = (x + y + z + w) * F4; // Factor for 4D skewing
            var i = Math.floor(x + s);
            var j = Math.floor(y + s);
            var k = Math.floor(z + s);
            var l = Math.floor(w + s);
            var t = (i + j + k + l) * G4; // Factor for 4D unskewing
            var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
            var Y0 = j - t;
            var Z0 = k - t;
            var W0 = l - t;
            var x0 = x - X0; // The x,y,z,w distances from the cell origin
            var y0 = y - Y0;
            var z0 = z - Z0;
            var w0 = w - W0;
            // For the 4D case, the simplex is a 4D shape I won't even try to describe.
            // To find out which of the 24 possible simplices we're in, we need to
            // determine the magnitude ordering of x0, y0, z0 and w0.
            // Six pair-wise comparisons are performed between each possible pair
            // of the four coordinates, and the results are used to rank the numbers.
            var rankx = 0;
            var ranky = 0;
            var rankz = 0;
            var rankw = 0;
            if (x0 > y0) rankx++;
            else ranky++;
            if (x0 > z0) rankx++;
            else rankz++;
            if (x0 > w0) rankx++;
            else rankw++;
            if (y0 > z0) ranky++;
            else rankz++;
            if (y0 > w0) ranky++;
            else rankw++;
            if (z0 > w0) rankz++;
            else rankw++;
            var i1, j1, k1, l1; // The integer offsets for the second simplex corner
            var i2, j2, k2, l2; // The integer offsets for the third simplex corner
            var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
            // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
            // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
            // impossible. Only the 24 indices which have non-zero entries make any sense.
            // We use a thresholding to set the coordinates in turn from the largest magnitude.
            // Rank 3 denotes the largest coordinate.
            i1 = rankx >= 3 ? 1 : 0;
            j1 = ranky >= 3 ? 1 : 0;
            k1 = rankz >= 3 ? 1 : 0;
            l1 = rankw >= 3 ? 1 : 0;
            // Rank 2 denotes the second largest coordinate.
            i2 = rankx >= 2 ? 1 : 0;
            j2 = ranky >= 2 ? 1 : 0;
            k2 = rankz >= 2 ? 1 : 0;
            l2 = rankw >= 2 ? 1 : 0;
            // Rank 1 denotes the second smallest coordinate.
            i3 = rankx >= 1 ? 1 : 0;
            j3 = ranky >= 1 ? 1 : 0;
            k3 = rankz >= 1 ? 1 : 0;
            l3 = rankw >= 1 ? 1 : 0;
            // The fifth corner has all coordinate offsets = 1, so no need to compute that.
            var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
            var y1 = y0 - j1 + G4;
            var z1 = z0 - k1 + G4;
            var w1 = w0 - l1 + G4;
            var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
            var y2 = y0 - j2 + 2.0 * G4;
            var z2 = z0 - k2 + 2.0 * G4;
            var w2 = w0 - l2 + 2.0 * G4;
            var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
            var y3 = y0 - j3 + 3.0 * G4;
            var z3 = z0 - k3 + 3.0 * G4;
            var w3 = w0 - l3 + 3.0 * G4;
            var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
            var y4 = y0 - 1.0 + 4.0 * G4;
            var z4 = z0 - 1.0 + 4.0 * G4;
            var w4 = w0 - 1.0 + 4.0 * G4;
            // Work out the hashed gradient indices of the five simplex corners
            var ii = i & 255;
            var jj = j & 255;
            var kk = k & 255;
            var ll = l & 255;
            // Calculate the contribution from the five corners
            var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
            if (t0 < 0) n0 = 0.0;
            else {
                var gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;
                t0 *= t0;
                n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
            }
            var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
            if (t1 < 0) n1 = 0.0;
            else {
                var gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;
                t1 *= t1;
                n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
            }
            var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
            if (t2 < 0) n2 = 0.0;
            else {
                var gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;
                t2 *= t2;
                n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
            }
            var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
            if (t3 < 0) n3 = 0.0;
            else {
                var gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;
                t3 *= t3;
                n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
            }
            var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
            if (t4 < 0) n4 = 0.0;
            else {
                var gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;
                t4 *= t4;
                n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
            }
            // Sum up and scale the result to cover the range [-1,1]
            return 27.0 * (n0 + n1 + n2 + n3 + n4);
        }


    };

    // amd
    if (typeof define !== 'undefined' && define.amd) define(function(){return SimplexNoise;});
    // browser
    else if (typeof window !== 'undefined') window.SimplexNoise = SimplexNoise;
    //common js
    if (typeof exports !== 'undefined') exports.SimplexNoise = SimplexNoise;
    // nodejs
    if (typeof module !== 'undefined') {
        module.exports = SimplexNoise;
    }

    