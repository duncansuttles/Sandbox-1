# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

--- 
extends: http://vwf.example.com/navscene.vwf
properties:
  clients: 
  DisplayName:
  placemarks:
    Origin: [0, 0, 0]
  navmode: none     
  sunColor: 
    value: [1, 1, 1]
    set: |
            if(!this.sun) return;
            this.sun.color.r = value[0];
            this.sun.color.g = value[1];
            this.sun.color.b = value[2];
  sunDirection: 
    value: [.5 , .5 , 1 ]
    set: |
            if(!this.sun) return;
            
            var x = value[2] * Math.sin(value[0])* Math.cos(value[1]);
            var y = value[2] * Math.sin(value[0])* Math.sin(value[1]);
            var z = value[2] * Math.cos(value[0]);
            
            this.sun.position.x = x;
            this.sun.position.y = y;
            this.sun.position.z = z;      
            this.sun.position.normalize();
            this.sun.position.multiplyScalar(100);
            this.sun.updateMatrixWorld(true);
  sunIntensity: 
    value: .8
    set: |
            if(!this.sun) return;
            this.sun.intensity = value;   
            this.sun.shadowDarkness = value;           
  ambientColor: 
    value: [.35, .35 , .35]
  fogColor: [1, 1, 1]
  fogNear: 100
  fogFar: 1000
  fogType: 0
  fogDensity: .005
  fogVFalloff: 1.3
  fogVFalloffStart: 0
  skyColorBlend: 0  
  skyFogBlend: 0  
  skyApexColor: [ 0 , .5 , 1.0 ]
  skyHorizonColor: [ 0 , .5 , 1.0 ]
  ___physics_gravity: [ 0, 0, -9.8]
  ___physics_accuracy: 10
  ___physics_active: true
  vAtmosphereDensity: .0005
  playMode: "paused"
  materialDef:
    set: |  
           this.materialDef = value;
           
           return this.setTexture(value);
    get: |  
           return this.getTexture();
  skyTexture:
    set: |
            
            this.skyTexture = value;
            if(!this.sun) return;
            this.CreateSky(value);
            
    get: |
             return this.skyTexture    
  owner:
  type: scene
  clientAPI:
    get : |
           
           if(this.___clientAPI) return this.___clientAPI;
           this.___clientAPI = {};
           this.___clientAPI.getUserNameForConnectionID = function(id)
           {
           	   if(!this.clients || !this.clients[id]) return null;
           	   		return this.clients[id].name;
           }.bind(this);
           this.___clientAPI.getConnectionIDForUserName = function(name)
           {
           	   if(!this.clients) return null;
           	   for(var i in this.clients.internal_val)
           	   {
           	   		if(this.clients[i].name == name)
           	   			return i;
           	   }
           	   return null;
           }.bind(this);
           this.___clientAPI.getAvatarForUserName = function(name)
           {
           	  return this.findNodeByID('character-vwf-' + name);
           }.bind(this);
           return this.___clientAPI;
  EditorData:
    fog:
      displayname: 'Fog'
      type: 'sectionTitle'
    fogNear:
      displayname: Fog Near
      property: fogNear
      type: slider
      min: 0
      max: 2000
      step: 1
    fogFar:
      displayname: Fog Far
      property: fogFar
      type: slider
      min: 0
      max: 2000
      step: 1
    fogDensity:
      displayname: Fog Density
      property: fogDensity
      type: slider
      min: 0
      max: .1
      step: .001
    fogvFAlloff:
      displayname: Fog Falloff
      property: fogVFalloff
      type: slider
      min: .1
      max: 10
      step: .001 
    fogvFAlloffStart:
      displayname: Fog Falloff Start
      property: fogVFalloffStart
      type: slider
      min: -100
      max: 100
      step: .1  
    sunIntensity:
      displayname: Sun Intensity
      property: sunIntensity
      type: slider
      min: 0
      max: 5
      step: .1      
    fogType:
      displayname: Fog Type
      property: fogType
      type: choice
      labels:         
        - None
        - Linear
        - Quad
      values:
        - null
        - linear
        - exp  
    fogColorR:
      displayname: Fog Color
      property: fogColor
      type: color
    sun:
      displayname: 'Sun'
      type: 'sectionTitle'  
    sunambientColor:
      displayname: ambient
      property: ambientColor
      type: color     
    sunColor:
      displayname: Sun Color
      property: sunColor
      type: color
    sunRot:
      displayname: Sun Direction
      property: sunDirection
      type: vector
      step: .05
    sky:
      displayname: 'Sky'
      type: 'sectionTitle'  
    skyTexture:
      displayname: skyTexture
      property: skyTexture
      type: choice
      labels: 
        - CloudyNoon
        - Morning
        - Evening
        - Morning2
        - Storm
        - ThunderStorm
        - Night1
        - Night2
        - Bright
        - White
        - Black
      values:
        - cloudy_noon
        - early_morning
        - evening  
        - morning  
        - stormy
        - StormClouds   
        - night1
        - night2
        - bright
        - white
        - black
    skyColorBlend:  
      displayname: Sky Color Blend
      property: skyColorBlend
      type: slider
      min: 0
      max: 1
      step: .01  
    skyFogBlend:
      displayname: Sky Fog Amount
      property: skyFogBlend
      type: slider
      min: 0
      max: 1
      step: .01  
    skyAtmosphereDensity: 
      displayname: Atmosphere Density
      property: skyAtmosphereDensity
      type: slider
      min: 0
      max: 1
      step: .01     
    skyApexColor:
      displayname: Sky Apex Color
      property: skyApexColor
      type: color
    skyHorizonColor: 
      displayname: Sky Horizon Color
      property: skyHorizonColor
      type: color
events:
  disconnected:
  avatarCreated:
  clientConnected:
  clientDisconnected:
  pointerOver:
  pointerOut:
  pointerClick:
  pointerDown:
  pointerUp:
  pointerMove:
  keyDown:
  keyUp:
methods:  
  AmLocal:
  newplayer:
  deleteplayer:
  initialize:
  receiveChat:
  CreatePlane:
  PM:
  latencyTest:
  getSkyMat:
  cameraBroadcastStart:
  broadcastCameraPosition:
  tick:
  getBroadcasting:
  cameraBroadcastEnd:
  playSound:
  setMusic:
scripts:
- |
    this.initialize = function(){
 
       
       this.setCameraMode('Orbit');
       this.offset = [0,0,1];
       this.center = [0,0,0];
       this.flyspeed = 1;
       this.activeCameraComp = false;
       this.loaded = false;
       this.zoom = 4;
       this.x_rot = 0.15687500000000001;
       this.y_rot = 0.5839999999999994;
       //this.updateCamera();
       this.players = [];
       this.rel_x = 0;
       this.rel_y = 0;
       this.loaded= false;
       this.leftdown= false;
       this.middledown=false;
       this.rightdown= false;
       this.last_x = 0;
       this.last_y = 0;
       this.navmode = 'none';
     //  this.PickOptions = new MATH.CPUPickOptions();
     //  this.PickOptions.UserRenderBatches = true;
      
        $('#index-vwf').mousedown(function(e){this.localpointerDown(e);}.bind(this));
        window.addEventListener("deviceorientation", this.orientationEvent.bind(this), true);
        
        $('#index-vwf').mousewheel(function(e){e.deltaY *= -1; this.localpointerWheel(e);}.bind(this));
        $('#index-vwf').mouseup(function(e){this.localpointerUp(e);}.bind(this));
        $('#index-vwf').mouseleave(function(e)
        {
            if($(e.toElement).hasClass('glyph'))
            {
            
            }
            else
            {
            
                this.localpointerUp(e);
            }
            
        }.bind(this));
        $('#index-vwf').mousemove(function(e){this.localpointerMove(e);}.bind(this));

        $('#index-vwf')[0].addEventListener("touchstart", this.localTouchStart.bind(this), true);
        $('#index-vwf')[0].addEventListener("touchend", this.localTouchEnd.bind(this), true);
        $('#index-vwf')[0].addEventListener("touchmove", this.localTouchMove.bind(this), true);

       this.updateCallbacks = [];
       this.OwnedPrims = [];
      
       findcamera().fov = 70;
       findcamera().updateProjectionMatrix();
       var ground = new THREE.Mesh(new THREE.PlaneGeometry(256,256,10,10), new THREE.MeshPhongMaterial());
       ground.receiveShadow = _SettingsManager.getKey('shadows');
       ground.PickPriority = -1;
       
       
       var grassTex = THREE.ImageUtils.loadTexture('textures/gridnew.png');
       
      
       ground.material.map = grassTex;
        grassTex.wrapS = THREE.RepeatWrapping;
        grassTex.wrapT = THREE.RepeatWrapping;
        grassTex.repeat.x = 64;
        grassTex.repeat.y = 64;
       grassTex.anisotropy  = _dRenderer.getMaxAnisotropy();
       this.groundplane = ground;
       
       
       findscene().add(ground);
       
       if(this.materialDef)
       this.setTexture(this.materialDef);
       var l = new THREE.DirectionalLight();
       this.sun = l;
       this.sun.name = 'Sun';
       this.sun.castShadow = _SettingsManager.getKey('shadows');
       this.sun.shadowCameraNear = 1;
       this.sun.shadowCameraFar = 100;
       //this.sun.shadowCameraVisible = true;
       this.sun.shadowCameraBottom = -10;
       this.sun.shadowCameraLeft = -10;
       this.sun.shadowMapWidth = 1024;
       this.sun.shadowMapHeight = 1024;
       
       this.sun.shadowCameraTop = 10;
       this.sun.shadowCameraRight = 10;
       findscene().add(l);
       rebuildAllMaterials();
       
       this.sun.position.x = this.sunDirection[0];
       this.sun.position.y = this.sunDirection[1];
       this.sun.position.z = this.sunDirection[2];
       this.sun.position.normalize();
       this.sun.position.multiplyScalar(100);
       this.sun.intensity = this.sunIntensity;
       this.sun.shadowBias = -.005
       window._dGround = this.groundplane;
       this.groundplane.name = 'GroundPlane';
       //this.groundplane.visible = false;
       window._dSun = this.sun;
       
       this.sun.updateMatrixWorld(true);
       this.CreateSky(vwf.getProperty(this.id,'skyTexture') || 'white');
       /*findscene().setAmbientColor('rgb(200,200,200)');
       
       
      
       
       
       
       findscene().setFogType(MATH.FOG_QUADRATIC);
       findscene().setFogFar(360);
       findscene().setFogNear(100);
       findscene().setFogColor('#FFFFFF');
       
       */
         if(this.id == 'Scene-vwf') return;
          this.prerendercallback = this.prerender.bind(this);
          this.glyphrendercallback = this.glyphRender.bind(this);
          this.postprerendercallback = this.postprerender.bind(this);
          _dView.bind('prerender',this.prerendercallback);
          _dView.bind('postprerender',this.postprerendercallback);
          _dView.bind('glyphRender',this.glyphrendercallback);
          this.createNameTag();
          this.updateCamera();
    }
    this.tick = function()
    {
       
        if(this.broadcastingCamera)
        {
            vwf_view.kernel.callMethod('index-vwf','broadcastCameraPosition',[this.camera.transform]);
        }
        if(this.receivingCameraBroadcast && this.cameramode != 'None')
            this.receivingCameraBroadcast = false;
        
    }
    this.broadcastCameraPosition = function(transform)
    {
        if(this.receivingCameraBroadcast)
        {
          
            this.camera.transform = transform;
        }
    }
    this.getBroadcasting = function()
    {
        return this.broadcastingCamera;
    }
    this.cameraBroadcastStart = function()
    {
        if(this.client == this.moniker)
        {
            
            this.broadcastingCamera = true;
            this.receivingCameraBroadcast = false;
        }else
        {
            alertify.confirm(_UserManager.GetPlayernameForClientID(this.client) + " would like to share the camera view with you. Accept?",function(ok)
            {
                if(ok)
                {
                
                    this.broadcastingCamera = false;
                    this.receivingCameraBroadcast = true;
                    this.preCameraShareMode = this.cameramode;
                    this.cameramode = 'None';
                
                }
            
            }.bind(this));
            
        
        }
    
    }
    this.cameraBroadcastEnd = function()
    {
        if(this.client == this.moniker)
        {
            this.broadcastingCamera = false;
            this.receivingCameraBroadcast = false;
        }else
        {
            if(this.receivingCameraBroadcast)
            {
              alertify.alert((_UserManager.GetPlayernameForClientID(this.client) || 'The user') + " has stopped sharing the camera view.");
               this.broadcastingCamera = false;
              this.receivingCameraBroadcast = false;
              this.cameramode = this.preCameraShareMode;
            }
           
        }
    }
    this.cameraBroadcastPrompt = function()
    {
        
    
    }
    this.getSkyMat = function()
    {
    
        return this.skycube.material;
    
    }
    this.latencyTest = function(e)
    {
        if(this.moniker == this.client)
        {
            var time = new Date(e.time);
            var thistime = (new Date()) - time;
            _Notifier.alert("The round trip time to the server was: " + thistime +"ms");
        }
    }
    //the system is notifiying us that it has become disconnected from the server
    this.disconnected = function()
    {
        
        alert('This client has been disconnected from server. The page must be reloaded.');
        var user = _UserManager.GetCurrentUserID();
        
        try{vwf.deleteNode(user)} catch(e){};
        document[document.PlayerNumber +'link'] = null;
        document.PlayerNumber = null;
        _UserManager.currentUsername = null;
        window.onbeforeunload = null;
        $(window).unbind();
        window.location.reload();
    }
    //a new client has joined the simulation
    this.avatarCreated = function(id)
    {
    
    
    }
    //a new client has joined the simulation
    this.clientConnected = function(id,name,UID)
    {
     
    	if(!this.clients)
    	{
    		this.clients = {}
    	}
    	if(!this.clients[id])
    		this.clients.defineProperty(id,{cid:id,name:name,UID:UID});
    	
    }
    // a client other than this one has left
    this.clientDisconnected = function(id,name,UID)
    {
    	if(this.clients)
    	{
    		delete this.clients.internal_val[id];
    		this.clients = this.clients.internal_val;		
    	}
    }
    this.CreatePlane = function(width,height)
    {
        
        var hw = width/2;
        var hh = height/2;
        
        var planemesh = new MATH.Mesh();
       
        var planeobj = new MATH.Object();
        planeobj.PickPriority = 0;
        planeobj.setMesh(planemesh);
        planemesh.setPositions([-hw,-hh,-.001, hw,-hh,-.001, hw,hh,-.001, -hw,hh,-.001]);
        planemesh.setTangents([-hw,-hh,0, hw,-hh,0, hw,hh,0, -hw,hh,0]);
        planemesh.setFaces([0,1,2,2,3,0]);
        planemesh.setUV([0,0,250/4 ,0,250/4,250/4,0,250/4]);
        findscene().addChild(planeobj);
        planeobj.InvisibleToCPUPick = false;
        return planeobj;
    }
    this.CreateSky = function(sky_name)
    {
     
        ////console.log('set sky ' + sky_name);
       
       //var sky_name = 'cloudy_noon';
       var urls = [];

        
        urls.push('skys/'+sky_name+'_FR.jpg');
        urls.push('skys/'+sky_name+'_BK.jpg');
        urls.push('skys/'+sky_name+'_RT.jpg');
        urls.push('skys/'+sky_name+'_LF.jpg');
        urls.push('skys/'+sky_name+'_UP.jpg');
        urls.push('skys/'+sky_name+'_DN.jpg');
       
       
        
       var loaded = function(){
            this.skymaterial.uniforms.texture.value.image = skyCubeTexture.image;
            this.skymaterial.uniforms.texture.value.needsUpdate = true;
            this.skymaterial.uniforms.texture.value.wrapS = this.skymaterial.uniforms.texture.value.wrapT = THREE.RepeatWrapping;
       }.bind(this);
            var skyCubeTexture = THREE.ImageUtils.loadTextureCube(urls,undefined,loaded);
           // skyCubeTexture.format = THREE.RGBFormat;
            skyCubeTexture.generateMipmaps = true;
            skyCubeTexture.minFilter = THREE.LinearFilter;
            skyCubeTexture.magFilter = THREE.LinearFilter;
            skyCubeTexture.wrapS = THREE.ClampToEdgeWrapping;
            skyCubeTexture.wrapT = THREE.ClampToEdgeWrapping;

            
       if(!this.skymaterial)
       {
       
            
                this.skymaterial = new THREE.ShaderMaterial( {
                    uniforms:       THREE.ShaderLib.sky.uniforms,
                    attributes:     THREE.ShaderLib.sky.attributes,
                    vertexShader:   THREE.ShaderLib.sky.vertexShader,
                    fragmentShader: THREE.ShaderLib.sky.fragmentShader
                });
            this.skymaterial.uniforms.texture.value = skyCubeTexture;    

            this.skymaterial.depthWrite = false;
            this.skymaterial.depthTest= false;
            this.skymaterial.fog= true;
            this.skymaterial.lights= true;
            this.skymaterial.transparent = false;
            this.skymaterial.uniforms.texture.value = skyCubeTexture;    
            
       }
       
       
       this.skymaterial.side = 1;
       
      
       if(!this.skycube)
       {
           this.skycube = new THREE.Mesh(new THREE.SphereGeometry(1,10,20), this.skymaterial);
           this.skycube.name = "SkyCube";
           this.skycube.renderDepth = -Infinity;
           this.skycube.InvisibleToCPUPick = true;
           this.skycube.PickPriority = -1;
           this.skycube.depthWrite = false;
           this.skycube.depthCheck = false;
           this.skycube.castShadow = false;
           this.skycube.receiveShadow = false;
           findscene().add(this.skycube);
           
           window._dSky = this.skycube;
          
       }
        
    }
    this.removeUpdateCallback = function(m)
    {
        this.updateCallbacks.splice(m,1);
    }
    this.addUpdateCallback = function(val)
    {
        this.updateCallbacks.push(val);
        return this.updateCallbacks.length-1;
    }
    this.callUpdateCallbacks = function()
    {
        
        for(var i =0; i<this.updateCallbacks.length; i++)
         this.updateCallbacks[i](this);
    }
    this.followObject = function(value)
    {
        if(this.objectFollowed)
        {
            if(this.objectFollowed.updateCallbacks)
            {
                this.objectFollowed.updateCallbacks.splice(this.followcallbacknum,1);
            }
        }
        if(value)
        {
            if(value.updateCallbacks)
            {
                value.updateCallbacks.push(this.updateCamera.bind(this));
                this.followcallbacknum = value.updateCallbacks.length;
            }
        }
        this.objectFollowed = value; 
        //if(this.objectFollowed)
        //this.oldRotZ = vwf.getProperty(this.objectFollowed.id,'rotZ');
    }
    this.targetUpdated = function(obj)
    {
        if(typeof(obj) == "string")
            obj = vwf_view.kernel.kernel.models[0].model.nodes[obj];
        if(obj && obj.translation)
        {
        this.center = obj.translation;
        if(obj.followOffset != null)
            this.center = MATH.addVec3(obj.translation,obj.followOffset);
        }
        
    }
    this.lookat = function(posfrom,posto,pointfront)
    {
                
                var to = MATH.subVec3(posfrom,posto);
                to = MATH.scaleVec3(to,1.0/MATH.lengthVec3(to));
                var a = MATH.crossVec3(pointfront,to);
                var tofront = goog.vec.Quaternion.createFromValues( a[0], a[1], a[2], 1 + MATH.dotVec3(pointfront,to) );    
                var angle = 0; var axis = [0,0,1];
                var  tofront_norm = [];
                goog.vec.Quaternion.normalize(tofront,tofront_norm);    
                var currentrot = [];
               
                angle = goog.vec.Quaternion.toAngleAxis(tofront_norm,axis);
                return [axis[0],axis[1],axis[2],angle/0.0174532925];   
    }
    this.multTranslate=  function(mat, translate, result) {
     
        if(mat == undefined) return;
        if (result === undefined) {
            result = [];
        }
        if (result !== mat) {
            for(var i = 0; i < mat.length; i++)
                result.push(mat[i]);
        }

        var val;
        if (translate[0] !== 0.0) {
            val = translate[0];
            result[12] += val * mat[0];
            result[13] += val * mat[1];
            result[14] += val * mat[2];
            result[15] += val * mat[3];
        }

        if (translate[1] !== 0.0) {
            val = translate[1];
            result[12] += val * mat[4];
            result[13] += val * mat[5];
            result[14] += val * mat[6];
            result[15] += val * mat[7];
        }

        if (translate[2] !== 0.0) {
            val = translate[2];
            result[12] += val * mat[8];
            result[13] += val * mat[9];
            result[14] += val * mat[10];
            result[15] += val * mat[11];
        }
        return result;
    },
    this.normalize = function(vec)
    {   
    
        if(vec == undefined) return;
        return MATH.scaleVec3(vec,1.0/MATH.lengthVec3(vec));
    }
    this.makeLookAt = function(eye, center, up, result) {
    
        if(eye == undefined) return;
       
        if (result === undefined) {
            result = [];
        }

        var f = MATH.subVec3(center, eye);
        f = this.normalize(f);

        var s = MATH.subVec3(f, up);
        s = this.normalize(s);

        var u = MATH.crossVec3(s, f);
        u =this.normalize(u);

        // s[0], u[0], -f[0], 0.0,
        // s[1], u[1], -f[1], 0.0,
        // s[2], u[2], -f[2], 0.0,
        // 0,    0,    0,     1.0

        result[0]=s[0]; result[1]=u[0]; result[2]=-f[0]; result[3]=0.0;
        result[4]=s[1]; result[5]=u[1]; result[6]=-f[1]; result[7]=0.0;
        result[8]=s[2]; result[9]=u[2]; result[10]=-f[2];result[11]=0.0;
        result[12]=  0; result[13]=  0; result[14]=  0;  result[15]=1.0;
        
        var tra = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];        
        tra[12] = -eye[0];
        tra[13] = -eye[1];
        tra[14] = -eye[2];
        var newresult = MATH.mulMat4(result,tra);
        return newresult;
    }
    this.GetWorldPickRay = function(e)
    {
       return _Editor.GetWorldPickRay(e);
    }
    this.intersectLinePlane = function(ray,raypoint,planepoint,planenormal)
    {
        var n = MATH.dotVec3(MATH.subVec3(planepoint,raypoint),planenormal);
        var d = MATH.dotVec3(ray,planenormal);
        if(d == 0)
            return null;

        var dist = n/d;

        return dist;
    }
    this.touchcount = 0;
    this.lastTouchDist = 0;
    this.localTouchStart = function(event)
    { 
       this.touchcount ++;

       this.rightdown = true;
       this.last_x = event.touches[0].clientX/window.screen.width;
       this.last_y = event.touches[0].clientY/window.screen.height;

       if(event.touches.length == 2)
        {
             var x = (event.touches[0].clientX - event.touches[1].clientX)/2;
             var y = (event.touches[0].clientX - event.touches[1].clientX)/2;
             x *= x;
             y *= y;
             this.lastTouchDist = Math.sqrt(x+y);
        }
    }
    this.localTouchEnd = function(event)
    {
       this.touchcount --;
       this.rightdown = false;
    }
    this.localTouchMove = function(event)
    {
        if(event.touches.length == 1)
          this.localpointerMove(event.touches[0]);
        if(event.touches.length == 2)
        {

             var x = (event.touches[0].clientX - event.touches[1].clientX)/2;
             var y = (event.touches[0].clientX - event.touches[1].clientX)/2;
             x *= x;
             y *= y;
             var dist = Math.sqrt(x+y);
             var relDist = this.lastTouchDist - dist;
             if(Math.abs(relDist) > 3)
             {
             this.lastTouchDist = dist;
             event.touches[0].deltaY = relDist;
             this.localpointerWheel(event.touches[0]);
           }

             var x = (event.touches[0].clientX + event.touches[1].clientX)/2;
             var y = (event.touches[0].clientX + event.touches[1].clientX)/2;
             this.middledown = true;
             event.touches[0].clientX = x;
             event.touches[0].clientY = y;
             this.localpointerMove(event.touches[0]);
             this.middledown = false;

        }  
    }
    this.localpointerDown = function( parms, pickInfo ){
     
      if(!_dView.inDefaultCamera()) return;
      parms.preventDefault();
      if(parms.which == 1) this.leftdown = true;
      if(parms.which == 2) this.middledown = true;
      if(parms.which == 3) this.rightdown = true;
     

     
      if(parms.which == 3 || parms.which == 2 && (this.cameramode == 'Orbit' || this.cameramode == 'Free'))
        {
        // Ask the browser to lock the pointer
       // $('#index-vwf')[0].requestPointerLock();
        }      
     
      this.last_x = parms.clientX/window.screen.width;
      this.last_y = parms.clientY/window.screen.height;
      
      if(this.cameramode == 'Navigate' && parms.which == 2)
      {
            
           var campos = [_Editor.findcamera().position.x,_Editor.findcamera().position.y,_Editor.findcamera().position.z];
           var ray = this.GetWorldPickRay(parms);

          
         
           
            this.groundplane.PickPriority = 0;
           var oldintersectxy = _Editor.ThreeJSPick(campos,ray,this.PickOptions);
           if(!oldintersectxy) return; //this is just better. 
           oldintersectxy = oldintersectxy ? oldintersectxy.point : [0,0,0];
            this.groundplane.PickPriority = -1;
            var dxy2 = this.intersectLinePlane(ray,campos,[0,0,0],[0,0,1]);
           var oldintersectxy2 = MATH.addVec3(campos,MATH.scaleVec3(ray,dxy2));
            if(oldintersectxy2[2] > oldintersectxy[2]) oldintersectxy = oldintersectxy2;
          
           this.navpoint =  oldintersectxy;
      }
     
    }
    this.localpointerUp = function( parms, pickInfo ){
      
      if(!_dView.inDefaultCamera()) return;
      parms.preventDefault();
      if(parms.which == 1) this.leftdown = false;
      if(parms.which == 3) this.rightdown = false;
      if(parms.which == 2) this.middledown = false;
      if(parms.which == 2 || parms.which == 3)
        {
        // Ask the browser to lock the pointer
        //document.exitPointerLock();
        }    
    }
    this.localpointerMove = function( parms, pickInfo ){

      if(!_dView.inDefaultCamera()) return;
      if(document.AxisSelected != null)  
      if(document.AxisSelected != -1)
        return;
        
      if(this.rel_x == undefined) return;
      
      this.rel_x = this.last_x - parms.clientX/window.screen.width;
      this.rel_y = this.last_y - parms.clientY/window.screen.height;
      
      //only works with pointer lock
      if(parms.originalEvent && (this.rightdown==true || this.middledown==true))
      {
        this.rel_x = -(parms.originalEvent.webkitMovementX || parms.originalEvent.mozMovementX || parms.originalEvent.MovementX)/1000 || this.rel_x;
        this.rel_y = -(parms.originalEvent.webkitMovementY || parms.originalEvent.mozMovementY || parms.originalEvent.MovementY)/1000 || this.rel_y;
      }
      
      if((this.rightdown==true && this.middledown==false))
      {
        
        if(this.objectFollowed)
        {  
        	  var rz = this.lastRotZ || 0;
            this.lastRotZ  = (rz +(this.rel_x*5 || 0)) || 0;
            vwf_view.kernel.setProperty(this.objectFollowed.id,'rotZ',this.lastRotZ);
            
            
        }
        
        this.x_rot += this.rel_x;
        this.y_rot += this.rel_y;
        
        
      }
      
      if((this.cameramode == 'Orbit'|| this.cameramode == 'Free' ) && this.middledown == true )
      {
        
        
        var screenmousepos = [(parms.clientX-this.rel_x*1000)/window.screen.width,(parms.clientY-this.rel_y*1000)/window.screen.height,0,1];
        screenmousepos[0] *= 2;
        screenmousepos[1] *= 2;
        screenmousepos[0] -= 1;
        screenmousepos[1] -= 1;
        screenmousepos[1] *= -1;
        var worldmousepos = MATH.mulMat4Vec4(MATH.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos[0] /= worldmousepos[3];
        worldmousepos[1] /= worldmousepos[3];
        worldmousepos[2] /= worldmousepos[3];
       
        screenmousepos = [this.last_x,this.last_y,0,1];
        screenmousepos[0] *= 2;
        screenmousepos[1] *= 2;
        screenmousepos[0] -= 1;
        screenmousepos[1] -= 1;
        screenmousepos[1] *= -1;
        var worldmousepos2 = MATH.mulMat4Vec4(MATH.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos2[0] /= worldmousepos2[3];
        worldmousepos2[1] /= worldmousepos2[3];
        worldmousepos2[2] /= worldmousepos2[3];
       
       var panfactor = 10;
       if(this.cameramode == 'Free')
       panfactor = 50;
       
       ////console.log(this.zoom);
        this.center = MATH.addVec3(this.center,MATH.scaleVec3(MATH.subVec3(worldmousepos2,worldmousepos),panfactor * this.zoom));
        
        
      }
      
      if(this.cameramode == 'Navigate' && this.middledown == true)
      {   
         this.zoom += -this.rel_y*this.zoom*3.0;
      }
      
      this.last_x = parms.clientX/window.screen.width;
      this.last_y = parms.clientY/window.screen.height;
    }
    var tempvec = new THREE.Vector3(0,0,0);
    var tside = [0,0,0];
    var tfinaloffset = [0,0,0];
    var tfinalpos = [0,0,0];
    var XAXIS = [1,0,0];
    var YAXIS = [0,1,0];
    var ZAXIS = [0,0,1];
    var toffset = [0,0,0];
    var tstage2offset = [0,0,0];
    var txmatrix = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    var tcrossmatrix = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    function TempVec3(arr)
    {
        tempvec.x = arr[0];
        tempvec.y = arr[1];
        tempvec.z = arr[2];
        return  tempvec;
    }
    this.orientationEvent = function(e)
    {
        if(this.cameramode !== 'DeviceOrientation')
            return;

        
        var x =     (e.alpha) * .0174532925;
        var y = e.beta* .0174532925;
        var z = e.gamma* .0174532925

    var zee = new THREE.Vector3( 0, 0, 1 );
    var orient = THREE.Math.degToRad(90);
    var euler = new THREE.Euler();

    var q0 = new THREE.Quaternion();

    var q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis

      var quaternion = new THREE.Quaternion();
       euler.set(y,x,-z,'YXZ')
       quaternion.setFromEuler( euler );
       quaternion.multiply( q1 )
       quaternion.multiply(q0.setFromAxisAngle( zee, - orient ));
        findcamera().matrixAutoUpdate = false;

        var oldx =  findcamera().matrix.elements[12];
        var oldy =  findcamera().matrix.elements[13];
        var oldz =  findcamera().matrix.elements[14];
        findcamera().matrix.makeRotationFromQuaternion(quaternion);

        var r = new THREE.Matrix4();
        r.elements[0] = 1; r.elements[1] = 0;r.elements[1] = 0;
        r.elements[4] = 0; r.elements[5] = 0;r.elements[6] = 1;
        r.elements[8] = 0; r.elements[9] = -1;r.elements[10] = 0;
       
       r.multiply(findcamera().matrix);
        findcamera().matrix = r;
        findcamera().matrix.elements[12] = oldx;
        findcamera().matrix.elements[13] = oldy;
        findcamera().matrix.elements[14] = oldz;
       // console.log(e.alpha,e.beta,e.gamma);

    }
    this.updateCamera = function()
      {
        
        if(!_dView.inDefaultCamera()) return;
        
        try{
        if(this.objectFollowed != null)    
            this.targetUpdated(this.objectFollowed);
        }catch(e)
        {
          this.objectFollowed = null;
          console.error(e)
        }
        if(this.cameramode == 'None' || this.cameramode == 'DeviceOrientation')
        {
            return;
        }
        if(this.cameramode == 'Navigate' && this.navpoint)
        {
           var offset = MATH.subVec3(this.navpoint,this.center)
           var len = MATH.lengthVec3(offset);
           if(len > .01)
           {
              offset = MATH.scaleVec3(offset,.02);
              this.center = MATH.addVec3(this.center,offset);

           }

        }
        if(this.cameramode != '3RDPerson' && this.cameramode != 'FirstPerson')
        {
            
            if(this.x_rot == undefined) return;
            var xmatrix = MATH.angleAxis(this.x_rot*10,ZAXIS,txmatrix);
            
            var offset = MATH.mulMat4Vec3(xmatrix,XAXIS,toffset);
            offset = Vec3.scale(offset,1/MATH.lengthVec3(offset),offset);
            tside = Vec3.cross([0,0,1],offset,tside);
            
            if(this.y_rot < .479 ) this.y_rot = .479;
            if(this.y_rot > .783 && (this.cameramode != 'Free' && this.cameramode != 'Fly')) this.y_rot = .783;
            if(this.y_rot > .783 && (this.cameramode == 'Free' || this.cameramode == 'Fly')) this.y_rot = .783;
            
            var crossmatrix = MATH.angleAxis(this.y_rot*10,tside,tcrossmatrix);
            var stage2offset = MATH.mulMat4Vec3(crossmatrix,offset,tstage2offset);
            
            stage2offset = Vec3.scale(stage2offset,1/MATH.lengthVec3(stage2offset),stage2offset);
            tfinaloffset = Vec3.scale(stage2offset,this.zoom,tfinaloffset);
            if(this.center[2] < .05)
             this.center[2] = .05;
            tfinalpos = Vec3.add(tfinaloffset,this.center,tfinalpos);
            
           
            findcamera().position.x = tfinalpos[0];
            findcamera().position.y = tfinalpos[1];
            findcamera().position.z = tfinalpos[2];
            findcamera().lookAt(TempVec3(this.center));
            
           
        }else if(this.cameramode == 'FirstPerson')
        {
            try{
            //this.oldRotZ var xmatrix = MATH.angleAxis(this.x_rot*10,[0,0,1]);
            var rotation = this.objectFollowed.rotation;
          
            var offset = this.objectFollowed.transformAPI.localToGlobalRotation([0,1.5,.5]);
            
            offset = MATH.scaleVec3(offset,1/MATH.lengthVec3(offset));
            var side = MATH.crossVec3([0,0,1],offset);
           
            if(this.y_rot < .479 ) this.y_rot = .479;
            if(this.y_rot > .783 ) this.y_rot = .783;
            
            var crossmatrix = MATH.angleAxis(this.y_rot*10,side);
            var stage2offset = MATH.mulMat4Vec3(crossmatrix,offset);
            
            stage2offset = MATH.scaleVec3(stage2offset,1/MATH.lengthVec3(stage2offset));
            var finaloffset = MATH.scaleVec3(stage2offset,this.zoom);
            if(this.center[2] < .05)
             this.center[2] = .05;
            var finalpos = MATH.addVec3(finaloffset,this.center);
            
            //this.camera.translation = finalpos;
            findcamera().position.x = finalpos[0];
            findcamera().position.y = finalpos[1];
            findcamera().position.z = finalpos[2];
            findcamera().lookAt(TempVec3(this.center));
           
            findcamera().updateProjectionMatrix(true);
            this.zoom = .0001;
            }catch(e)
            {
              console.error(e);
            }
            
        }else  if(this.cameramode == '3RDPerson')
        {
            try{
            
            var offset = this.objectFollowed.transformAPI.localToGlobalRotation([0,1.5,.5]);
            
            var finaldist = MATH.lengthVec3(offset);  
            offset = MATH.scaleVec3(offset,1/finaldist);            
            var start = MATH.addVec3(this.center,MATH.scaleVec3(offset,.3));
            
            var oldpickstate = findviewnode(this.objectFollowed.id).PickPriority;
            
            var hit = _Editor.ThreeJSPick(start,MATH.scaleVec3(offset,1),{filter:function(o){ if(o instanceof THREE.Line) return false; return !(o.isAvatar === true || o.passable===true)}});
            if(hit)
            {
                finaldist = Math.min(finaldist,hit.distance-.2);
            }
            findviewnode(this.objectFollowed.id).PickPriority = oldpickstate;
            offset = MATH.scaleVec3(offset,finaldist);
            
            var finalpos = MATH.addVec3(offset,start);
            findcamera().position.x = finalpos[0];
            findcamera().position.y = finalpos[1];
            findcamera().position.z = finalpos[2];
            findcamera().lookAt(TempVec3(this.center));
            }catch(e)
            {
              console.error(e)
            }
            
        } 
        this.callUpdateCallbacks();
        findcamera().updateMatrixWorld();
        findcamera().updateMatrix();
       
      }
      function findscene()
      {
             return vwf.views[0].state.scenes["index-vwf"].threeScene;
      }
      function findcamera()
      {
             return _Editor.findcamera();
      }
      function matcpy(mat)
      {
        var newmat = [];
        for(var i = 0; i < 16; i++)
            newmat[i] = mat[i];
        return newmat;    
      }
      function getViewProjection()
      {
        var cam = findcamera();
        cam.matrixWorldInverse.getInverse( cam.matrixWorld );

        var _viewProjectionMatrix = new THREE.Matrix4();
        _viewProjectionMatrix.multiplyMatrices( cam.projectionMatrix, cam.matrixWorldInverse );


        return MATH.transposeMat4(_viewProjectionMatrix.toArray([]));
      }
      function to3Vec(vec,two,three)
      {
        if(vec.length)
            return new THREE.Vector3(vec[0],vec[1],vec[2]);
        else
            return new THREE.Vector3(vec,two,three);
      }
    this.setCameraMode = function(mode)
    {
        this.cameramode = mode;
        if(this.cameramode == 'Orbit')
            this.followObject(null);
        if(this.cameramode == 'Navigate')
            this.navpoint = this.center;
        if(this.cameramode == 'Free' || this.cameramode == 'Fly')
        {
           this.ReprojectCameraCenter();
           this.followObject(null);
        }
    }
    this.orbitPoint = function(point)
    {
        this.setCameraMode('Orbit');
        var campos = [_Editor.findcamera().position.x,_Editor.findcamera().position.y,_Editor.findcamera().position.z];
        var diff = MATH.subVec3(campos,point);
        var length = MATH.lengthVec3(diff);
        diff = MATH.scaleVec3(diff,1.0/length);
        //this.offset = diff;
        this.zoom = length;
        this.center = point;
        this.objectFollowed = null;
        
    }
    this.ReprojectCameraCenter = function()
    {
            var campos = [findcamera().position.x,findcamera().position.y,findcamera().position.z];
            var worldmousepos  = this.GetCameraCenterRay();
            worldmousepos = MATH.scaleVec3(worldmousepos,.4);
            this.center = MATH.addVec3(worldmousepos,campos);  
            this.zoom = .4;
    }
    this.GetCameraCenterRay = function()
    {
        var screenmousepos = [0,0,0,1];
        var worldmousepos = MATH.mulMat4Vec4(MATH.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos[0] /= worldmousepos[3];
        worldmousepos[1] /= worldmousepos[3];
        worldmousepos[2] /= worldmousepos[3];


         var campos = [findcamera().position.x,findcamera().position.y,findcamera().position.z];
        var ray = MATH.subVec3(worldmousepos,campos);
        var dist = MATH.lengthVec3(ray);
        ray = MATH.scaleVec3(ray,1.0/MATH.lengthVec3(ray));
        return ray;
    }    
    this.pointerLeave = function( parms ){

    }
    this.localpointerWheel = function( pickInfo ) {
       
        
        if(this.cameramode != 'Free'  && this.cameramode != 'Fly' && this.cameramode != 'Navigate')
        { 
          
            
            if(this.zoom < .4 && pickInfo.deltaY < 0)
            {
                var campos = [findcamera().position.x,findcamera().position.y,findcamera().position.z];
                var worldmousepos  = this.GetCameraCenterRay();
                worldmousepos = MATH.scaleVec3(worldmousepos,1);
                this.center = MATH.addVec3(worldmousepos,campos);  
                this.zoom = 1;
            }else
            {
                if(pickInfo.deltaY < 0 )
                this.zoom *= .9;
                else
                this.zoom *= 1.1;
            }
        }
       
        
        if(this.cameramode == 'Free' )
        { 
            if(pickInfo.deltaY > 0 )
            this.center = MATH.subVec3(this.center,this.GetCameraCenterRay());
            else
            this.center = MATH.addVec3(this.GetCameraCenterRay(),this.center);
            
        }
        if(this.cameramode == 'Fly')
        {
            if(pickInfo.deltaY > 0 )
            this.flyspeed *= 1.1;
            else 
            this.flyspeed *= .9;
            
            alertify.log('Flying at ' + Math.floor(75 / this.flyspeed) + ' mph');
        }
        if(this.cameramode == 'FirstPerson' && pickInfo.deltaY > 0)
        {
            this.cameramode = '3RDPerson';
        }
        else if(this.cameramode == '3RDPerson' && pickInfo.deltaY < 0)
        {
            this.y_rot =.6245;
            this.cameramode = 'FirstPerson';
        }
        
    }
    this.receiveChat = function(e)
    {
        if(window.ChatMessageReceived)
          ChatMessageReceived(e);
    }
    this.PM = function(e)
    {
        if(window.PMReceived)
        PMReceived(e);
    }
    function nodeExists(tempid)
    {
        for(var i in vwf.models.object.objects)
            if (vwf.models.object.objects[i].properties.tempid == tempid) return true;
        
        return false;
    }
    
    function findviewnode(id)
    {
        for(var i =0; i<vwf.views.length;i++)
        {
            if(vwf.views[i].state.nodes[id].threeObject) return vwf.views[i].state.nodes[id].threeObject;
        }
        return null;
    }
    
    this.newplayer = function(e)
    {
        
       
        
    }
    
    this.getTexture = function()
    {
            if(this.materialDef) return this.materialDef;    
           
            return {
                    shininess:15,
                    alpha:1,
                    ambient:{r:.8,g:.8,b:.8},
                    color:{r:1,g:1,b:1,a:1},
                    emit:{r:0,g:0,b:0},
                    reflect:0.8,
                    shadeless:false,
                    shadow:_SettingsManager.getKey('shadows'),
                    specularColor:{r:0.5773502691896258,g:0.5773502691896258,b:0.5773502691896258},
                    specularLevel:1,
                    layers:[
                      {  alpha: 1,
                        blendMode: 0,
                        mapInput: 0,
                        mapTo: 1,
                        offsetx: .11,
                        offsety: .11,
                        rot: 0,
                        scalex: 250/9,
                        scaley: 250/9,
                        src: "textures/grid2.gif"}
                    ]
            }            
    
    }
    this.setTexture = function(value)
    {
             if(this.groundplane)
              _MaterialCache.setMaterial(this.groundplane,value)       
    }
    this.createNameTag = function()
    {
    
      var newdiv = document.createElement('img');
      
      $(newdiv).addClass('glyph');
      newdiv.style.position = 'absolute';
      newdiv.id = "Player " + this.name + 'icon';
      //newdiv.innerHTML = "" + this.name;
      $(newdiv).attr('src','../vwf/view/editorview/images/icons/scene.png');
      newdiv.style.left = '0px';
      newdiv.style.top = '0px';
      
      $('#glyphOverlay').append(newdiv);
      $(newdiv).disableSelection();
            $(newdiv).mousedown(function(e){$('#index-vwf').focus(); if(_Editor.GetSelectMode() == "None" || e.which != 1) $('#index-vwf').trigger(e)});
      $(newdiv).mouseup(function(e){$('#index-vwf').focus();$('#index-vwf').trigger(e)});
      $(newdiv).mousemove(function(e){$('#index-vwf').trigger(e)});
      $(newdiv).click(function(e){$('#index-vwf').focus(); if(_Editor.GetSelectMode() != "None") _Editor.SelectObjectPublic(this.id)}.bind(this));
      this.nametag = newdiv;
                 
    }
    this.deinitialize = function()
    {
       _dView.unbind('prerender',this.prerendercallback);
       _dView.unbind('postprerender',this.postprerendercallback);
       _dView.unbind('glyphRender',this.glyphrendercallback);
       $(this.nametag).remove();
    }
    this.prerender = function()
    {
        
       
        if(this.cameramode == 'Fly')
        { 
            var dist = window.deltaTime/(this.flyspeed * 30.0);
            var forward = new THREE.Vector3(0,0,-1);
            var center = new THREE.Vector3(0,0,0);
            var cam = findcamera();
            forward.applyMatrix4(cam.matrixWorld);
            center.applyMatrix4(cam.matrixWorld);
            var offset = forward.sub(center);
            
            offset.setLength(.400 + dist);
            
            center.add(offset);
            this.center = [center.x,center.y,center.z];
            findcamera().position = center;
            
            
            
        }
        
        
        this.updateCamera();
        
    }
    this.tempmatrix = (new THREE.Matrix4());
    this.lightvec = new THREE.Vector3(0,0,-3);
    this.glyphRender = function(e,viewprojection, wh, ww)
    {

      
      var div = this.nametag;
      var pos = [0,0,0,1];
      
      
      var screen = MATH.mulMat4Vec4(viewprojection,pos);
      screen[0] /= screen[3];
      screen[1] /= screen[3];
     
      screen[0] /= 2;
      screen[1] /= 2;
      screen[2] /= 2;
      screen[0] += .5;
      screen[1] += .5;
      
  
      screen[0] *= ww;
      screen[1] *= wh;
      
     
      screen[1] = wh - screen[1];

      div.style.top = (screen[1]+35)  +  'px';
      div.style.left = (screen[0]  - 20/2)  +'px';
     
     
      if((screen[0] < 0 || screen[0] > ww || screen[1] < 0 || screen[1] > wh))
      {
            if(div.style.display != 'none')
                div.style.display = 'none';
      }
      else
      {
          if((screen[2] > 10 || screen[2] < 0) && div.style.display != 'none')
             div.style.display = 'none';
          if(screen[2] < 10 && screen[2] > 0 && div.style.display == 'none')
             div.style.display = 'block';
      }

    }
    this.postprerender = function(e,viewprojection, wh, ww)
    {
     
     if( this.skycube && this.skycube.geometry.boundingSphere) 
      this.skycube.geometry.boundingSphere.radius = Infinity;
      //focus the shadow camera projection matrix around the camera tha views the scene.
      if(this.sun && this.sun.shadowCamera)
      {
       
      
       this.lightvec.x = 0;
       this.lightvec.y = 0;
       this.lightvec.z = -3;
       var campos = findcamera().localToWorld(this.lightvec);
       
       this.sun.shadowCamera.updateMatrixWorld(true)
        var lm = this.sun.shadowCamera.matrixWorld.clone();
        lm = this.tempmatrix.getInverse(lm);
        var camposLS = campos.applyMatrix4(lm);
        
       
        
        this.sun.shadowCamera.projectionMatrix.makeOrthographic(camposLS.x - 15,camposLS.x + 15,camposLS.y - 15,camposLS.y+15,-camposLS.z - 15 ,-camposLS.z + 15 );
        }
    }    


      this.pointerOver = function(){return true;}
    this.pointerOut= function(){return true;}
    this.pointerClick= function(){return true;}
    this.pointerDown= function(){return true;}
    this.pointerUp= function(){return true;}
     this.pointerMove= function(){return true;}


        
    
    
 
 
   

   
