<!DOCTYPE html><html><head><LINK href='/docs/css/style.css' rel='stylesheet' type='text/css'></head><script src="/docs/scripts/jquery-1.7.1.js" ></script><script src="/docs/scripts/createTOC.js" ></script><script src="/docs/scripts/breadcrumbs.js" ></script></head><body><div class='article'><h1>Building a game in the Virtual World Sandbox</h1><h2>Introduction</h2><p>This document will walk you through the entire process of building a simple game in the VWS environment. It will cover the entire process from start to finish, including creating an account, setting up the scene, creating the objects, scripting the game and finally, publishing. This document assumes that you have some basic knowledge of web browsers and computers in general, but should not require any special prerequisites. By the end of this tutorial, you should have a functioning game you can play, and a good understanding of how to author content in the VWS application.</p><h2>Part 1: Getting started</h2><p>First things first, we'll need to get step before we can start building. This section will walk you through the steps necessary to get a user account and create a world.</p><div><h6>1. </h6><p>First, browse to <a href='http://vwf.adlnet.gov' >http://vwf.adlnet.gov</a> . You should see a website that looks something like the following.</p></div><img src='images\Image0.png' /><div><h6>2. </h6><p>Before we can create an application, we'll need to sign in. I assume here that you do not have an account. If you have already signed up for an account, go ahead and skip a few steps. Otherwise, You'll need to click the "Sign Up" button.</p></div><img src='images\Image1.png' /><div><h6>3. </h6><p>You should now see a screen where you can choose a username and a password. Be sure the password is something you can remember! You're username can be anything, so long as it is not currently used by another user. I recommend using an email address.</p></div><img src='images\Image2.png' /><div><h6>4. </h6><p>Now that you have created a user account, you'll be automatically logged into the website. You'll know you're logged in because you'll see your user name in the top right corner.</p></div><img src='images\Image3.png' /><div><h6>5. </h6><p>Next, we'll need to create a new world to work in. To do this, click the 'Create' button on the home page.</p></div><img src='images\Image4.png' /><div><h6>6. </h6><p>You'll see the following page. This page allows you to create a new world based on an existing 'template' world. In this case, we're going to just create a blank world. You should see the words "Create a world based on an empty world." When you click on one of the template world images, you'll select this template, and the text "Create a world based on ..." will change to show the name of the selected world. The template we need, the blank world, is the default. If you do click on one of the other templates, just scroll to the right end of the list, and click the template "an empty world". Give your new world a title and a description.</p></div><img src='images\Image5.png' /><div><h6>7. </h6><p>Click the Create button.</p></div><img src='images\Image6.png' /><div><h6>8. </h6><p>Great! If everything went according to plan, you should see the new world begin to load. Because this world is in editing mode, you'll see a lot of buttons and graphics appear in bars on the top, bottom, and sides of your browser. These are the tools that we'll be using in the next section. You'll also see the default avatar and a white grid in the center of the screen. This avatar is you! We won't be going into any details about how the avatar works today, so just ignore it for now.</p></div><img src='images\Image7.png' /><p class='note'><em>Note: </em>The VWS website uses a lot of cutting edge HTML5 features. If your browser window does not look like the image above, check that you are using the most recent version of Chrome, Firefox, Safari or Internet Explorer. Many mobile versions of these browsers may not be supported.</p><div><h6>9. </h6><p><em>Congratulations! </em>You've made it to the end of part one! Now is a good time to get used to moving around in this world. Click and hold with the right mouse button, and drag your mouse. Notice how the view rotates? This is the primary camera mode we'll use when authoring, so it pays to practice a little bit. You can also roll the mouse wheel to zoom in and out, or press and drag with the center mouse button (sometimes the wheel itself is the button, can be pressed in addition to being rolled) to pan the view. Don't worry too much about the left mouse button. It's used for selection, which you'll get plenty of practice with in the next section.</p></div><p class='note'><em>Note: </em>Don't be afraid to play around. At this point, the worst thing that can happen is that you create some junk in the world that will mess up our tutorial. You can always create another world to start the tutorial again.</p><h2>Part 2: Setting up the scene</h2><p>Now that we have a world to work in, we need to create all the objects that will be part of our game. We're going to have to create, move, modify, select, copy and paste a lot of objects for this section. I'm going to show you the basic tools and how they work, but leave it up to you to setup all the pieces once you know how. To start, we need to build some walls to create the game board.</p><div><h6>1. </h6><p>First, rotate your camera so you are looking down at the grid. This will help you stay oriented, and makes selecting object and moving them around easier. Zoom out a bit too.</p></div><img src='images\Image8.png' /><p class='remember'><em>Remember: </em>Zoom by rolling the mouse wheel, rotate the camera by clicking and dragging with the right mouse button</p><p class='info'><em>Info: </em>You can move the avatar out of the way by pressing and holding the 'W' button on the keyboard. You'll see a slight blue outline when the window is active and accepting keyboard commands.</p><div><h6>2. </h6><p>Now, we need to activate a tool that will let us draw the level. Find the 'Tools' menu on the top menubar. Click the 'Block Painter' menu item.</p></div><img src='images\Image9.png' /><div><h6>3. </h6><p>When the Block Painter tool opens, you'll see it slide out on the right, in an area we call the "side panel". The block painter is a quick and easy way to create a lot of geometry quickly. There are other ways you could lay out the level, but this is fun! Let's pick a different texture for our walls by clicking right on the "Pick Texture" button.</p></div><img src='images\Image10.png' /><div><h6>4. </h6><p>The Map Browser will appear. This is the tool that is used in many parts of the software whenever you need to choose a texture map. Clicking on the folder icons will show the textures inside that folder, and clicking on an image will select that file as the texture. You can also use the plus icon to enter a texture via URL. For now, let's keep it simple and choose the brick texture. Just click right on the small image of bricks.</p></div><img src='images\Image11.png' /><div><h6>5. </h6><p>The Painter tool will now show the selected texture, and the Map Browser window will disappear. We now need to activate the tool, and set it to 'Build' mode. Click the "Active" button inside the tool's panel, then click 'Build'. The "Active" button should remain lit up.</p></div><img src='images\Image12.png' /><div><h6>6. </h6><p>When you hold your mouse within the 3D window, over the grid, you'll see a faint transparent brick box. The tool is previewing where the next box will be placed. Click and hold with the left mouse button to make a stroke. Boxes will line up along the path of your stroke!</p></div><img src='images\Image13.png' /><p class='info'><em>Info: </em>You can also delete blocks with the painter tool. Just click the 'delete' button to put the tool into delete mode. Now, when you click and drag, boxes will be destroyed instead of created. Click 'Build' to start building again.</p><p class='note'><em>Note: </em>The Sandbox application currently does not support an undo feature. You have been warned!</p><div><h6>7. </h6><p>Build a maze! Be sure that each path within the maze is just one block thick. This won't be all that important, but it will make the game work better. Take some time to build something simple like the image below.</p></div><img src='images\Image14.png' /><div><h6>8. </h6><p>Great! We now have our game board. Now that we're done with the painter tool, we need to deactivate it so that we can go about the rest of our project. Click the 'Active' button in the tool again, so that it is no longer lit up. Now, click the 'X' button in the tool's title bar to close the tool. It's very important that you deactivate the tool before you close it - otherwise it can be active, just hidden!</p></div><div><h6>9. </h6><p>Now that we have our game board, we need to create our first actor! This actor will become the Player later, when we add scripts. We'll use a sphere for the player. Click the Sphere icon on the main toolbar.</p></div><img src='images\Image15.png' /><div><h6>10. </h6><p>You should see a sphere object appear right in the center of the viewport. By default, that sphere is checkered. We'll change this in a moment. First, we need to select the sphere so we can edit it. To do so, we first need to put the software into selection mode. Click the 'Select by clicking' button on the toolbar. You'll know select mode is active when the button turns blue.</p></div><img src='images\Image16.png' /><p class='info'><em>Info: </em>You can also enter selection mode with the hotkey 'Q' on the keyboard</p><div><h6>11. </h6><p>Now, click on the sphere in the main 3D window once with the left mouse button. You should see a white outline appear around the sphere, as well as a brightly colored axis graphic. It should look something like this:</p></div><img src='images\Image17.png' /><p class='remember'><em>Remember: </em>IT's very important that the Painter Tool is deactivated. If you are still seeing a faint box following under your cursor, the tools it active but hidden. Open is as we did in step 2, deactivate it by clicking the Active button. Verify that the button is not lit, then close the tool.</p><div><h6>12. </h6><p>Because we don't know exactly where the sphere was created (it's created at the center of your view) let's go ahead and reset its position, rotation, and scale. Find the 'Edit' menu on the menu bar, then open the sub menu 'Transforms' and finally, choose 'Reset Transforms'. This will zero out the position, rotation and scale of the sphere.</p></div><img src='images\Image18.png' /><div><h6>13. </h6><p>Now, we need to go ahead and name the sphere so that we can find it later. All objects have a set of properties you can edit in a window called the Property Editor. We need to open the property editor, and change the Display Name property of the sphere to something nice, like 'Player'. First, while the sphere is still selected, open the Property Editor by finding the 'Properties' tab on the right side of the screen.</p></div><img src='images\Image19.png' /><div><h6>14. </h6><p>Click it to open the <em>Property Editor</em>. It will appear in the side panel just like the painter tool did. Find the <em>Display Name </em>property, which is the first textbox on the page, and change the value to '<em>Player' </em>by clicking in the box and typing.</p></div><img src='images\Image20.png' /><p class='info'><em>Info: </em>The active text field, where the text from the keyboard is input, will be outlined in blue.</p><div><h6>15. </h6><p>We also need to make the sphere smaller. The properties that you can edit are divided into categories. The parameters for the generation of primitive objects like spheres and boxes will be under the 'Primitive' category. Click the '<em>Primitive: Sphere1' </em>then find the <em>Radius </em>setting. Either type in the box, or use the slider to change the radius to <em>.5</em></p></div><p class='note'><em>Note: </em>Don't be confused that the tab says 'Primitive: Sphere1' even though we just changed the object's name to Player. The UI will update the next time it's loaded.</p><img src='images\Image21.png' /><div><h6>16. </h6><p>Now, since the sphere was centered at (0, 0, 0). So that the object is not intersecting the ground, let's move it up. We'll do so precisely by typing in the Z value. Still in the Property Editor, Open the <em>Transform Tab</em>, and find the 3rD text box from the left under the Translation label. This value is the Z coordinate of the spheres position. Enter <em>".6". </em>You'll see the sphere move slightly.</p></div><img src='images\Image22.png' /><div><h6>17. </h6><p>Next, let's go ahead and make the sphere yellow, just for kicks. Find the <em>Material </em>tab. Its right below the Properties tab on the right of the screen. When you click this tab, the <em>Material </em>Editor will load into the side panel.</p></div><img src='images\Image23.png' /><div><h6>18. </h6><p>So, we want to do two things. First, click the little white square next to <em>"Diffuse Color." </em>This will let you change the color of the object. Click and drag in the color preview to set the diffuse color to yellow.</p></div><img src='images\Image24.png' /><div><h6>19. </h6><p>Let's also remove the default texture layer. The material editor allows you to link several different images to different properties of the surface, like a color map or a bump map. The default material has a checker texture for the diffuse map. Each texture gets a small tab at the bottom of the Material Editor. Click the "<em>Texture Layer 0</em>" tab to open the settings for the layer, then find the '<em>Delete Layer' </em>button. The sphere should now be a solid yellow. I've deselected it so you can see it better in the image below, but you should still see the selection outline and the brightly colored axis graphic.</p></div><img src='images\Image25.png' /><div><h6>20. </h6><p>Now, I've got a challenge for you. We need to create a cube with a <em>width length and height </em>of .25. I'd also like you to color it blue, and remove its default checker texture as well. Finally, I want you to position it so that it's in the center of a path, with its Z coordinate at .6. Look over the instructions above, and I'm sure you can figure it out. Also, go ahead and name it '<em>Food1'</em>. When you're done, you should have something that looks like this:</p></div><img src='images\Image26.png' /><div><h6>21. </h6><p>The next step is vital. We need to mark this object so that we can identify it from within the code later. Because there are going to be a lot of food objects, remembering all their names is going to be hard. Instead, we'll assign a custom property to the object called '<em>gametype'</em>. We'll make the value of this property '<em>food'</em>. While the first food object is selected, click the '<em>Scripts' </em>tab on the right of the screen to open the Script Editor. When the Script Editor opens, find and click the <em>Property </em>tab.</p></div><img src='images\Image27.png' /><p class='note'><em>Note: </em>We'll take much more about the Script Editor in part 3. For now, let's just add the property and not worry about the rest.</p><div><h6>22. </h6><p>Now, find the button in the bottom right that says <em>'New Property'. </em>Click it.</p></div><img src='images\Image28.png' /><div><h6>23. </h6><p>When the prompt opens, type '<em>gametype'</em>. This will be the name of the new property. Click <em>OK</em></p></div><img src='images\Image29.png' /><div><h6>24. </h6><p>On the next prompt, enter '<em>food'</em>. This will be the value of the new property. Click <em>OK</em></p></div><img src='images\Image30.png' /><div><h6>25. </h6><p>You can now close the Script Editor. Use the <em>down arrow </em>on the right at the top of the panel.</p></div><img src='images\Image31.png' /><p class='note'><em>Note: </em>It's very important that this step is successful. You can verify that the property was created by finding it in the list of properties on the left of the Properties Tab. If you see a button labeled 'gametype', we're good to go.</p><div><h6>26. </h6><p>We also need to mark the food object as 'passable'. This will allow the player to move through the food without colliding with it later in part 3. In the Properties Editor for the Food object, find and select the '<em>passable' </em>checkbox.</p></div><img src='images\Image32.png' /><div><h6>27. </h6><p>We now have to copy the Food0 object to each point on the game along the paths. While keyboard focus is on the main 3D view, you can hit <em>CTRL+D </em>duplicate the selected object. Duplicate the object, the click and drag along the RED or GREEN axis of the brightly colored axis graphic. You should see a new box move under the cursor.</p></div><img src='images\Image33.png' /><div><h6>28. </h6><p>Take some time and fill the game board with food objects as necessary. The editor tools have many options to make this faster. With some practice, you can do this in just a few minutes.</p></div><img src='images\Image34.png' /><p class='info'><em>Info: </em>You can select more than one object at a time, and move or duplicate whole rows of food! Click and drag with the left mouse button to draw a rectangle on the screen. All objects in the rectangle will be selected. You can hold CTRL or ALT to add or subtract from the selection as well.</p><p class='remember'><em>Remember: </em>You must be in selection mode before you can click to select objects.</p><div><h6>29. </h6><p>Using the same technique you've now mastered, duplicate the player object. Change its color to red, move it to the corner of the board, and name it Ghost.</p></div><img src='images\Image35.png' /><div><h6>30. </h6><p>Now, lets just remove that black and white grid. The texture of the default ground grid can be changed by editing the material of the Scene object. To select the scene, use the dropdown menu. Find <em>Edit->Select->Select Scene.</em></p></div><img src='images\Image36.png' /><div><h6>31. </h6><p>Not much will appear to change, but the material editor will now control the texture of the background grid. Use the material editor just like before to create a solid white background.</p></div><h2>Part 3: Scripting</h2><p>Alright! Now we are cooking with fire. The whole scene is set up, and we just need to make the game work. To do so, we need to add some behaviors to the objects. This means we'll have to write some code. This isn't a programming course, and I'm not going to discuss every line of text. Instead, I'll give you the code, and you can apply it to the objects. For anyone familiar with JavaScript, you'll immediately see hundreds of way to make this game more interesting, but let's stick with the basics for now.</p><div><h6>1. </h6><p>First, let's do the player code. Select the Player object, and open up the script editor. Make sure you're on the Methods tab, and scroll down the list on the left until you see the word 'tick'. It should appear greyed out. Click it.</p></div><img src='images\Image37.png' /><div><h6>2. </h6><p>The system will ask you if you want to create a new method called 'tick'. Click ok. 'Tick' is the method that the engine will call at every frame of animation to update your objects.</p></div><img src='images\Image38.png' /><div><h6>3. </h6><p>Now, paste the below code in the script window.</p></div><pre><code>function tick(){    if (this.motionVec)    {        var oldpos = this.transformAPI.getPosition();        this.transformAPI.move(this.motionVec, 'parent');        var hit = _SceneManager.SphereCast(this.transformAPI.getPosition(), .35,        {            ignore: [_Editor.findviewnode(this.id).children[0].children[0], _Editor.GetMoveGizmo()],            filter: function(n)            {                if (n.passable) return false;                return true;            }        });        if (hit && hit.length)        {                        this.transformAPI.setPosition(oldpos);        }    }}</pre></code><div><h6>4. </h6><p>Click 'Save Method' to save this code on the object as the Tick method.</p></div><img src='images\Image39.png' /><div><h6>5. </h6><p>Now, move over to the 'Events' tab, and click the '<em>keyDown' </em>suggestion on the left. This process is very similar to the process to create the 'Tick' method. Enter the code below into the '<em>KeyDown' </em>event, and save it.</p></div><pre><code>function keyDown(eventData, nodeData){    if (eventData.keysDown.rightarrow)    {        this.motionVec = [0, -.5, 0];        this.movestate = 'up';    }    if (eventData.keysDown.leftarrow)    {        this.motionVec = [0, .5, 0];        this.movestate = 'down';    }    if (eventData.keysDown.uparrow)    {        this.motionVec = [.5, 0, 0];        this.movestate = 'left';    }    if (eventData.keysDown.downarrow)    {        this.motionVec = [-.5, 0, 0];        this.movestate = 'right';    }}</pre></code><div><h6>6. </h6><p>Finally, insert and save the following code in the '<em>keyUp' </em>event.</p></div><pre><code>function keyUp(eventData, nodeData){    if (eventData.keysUp.rightarrow && this.movestate == 'up')    {        this.motionVec = null;    }    if (eventData.keysUp.leftarrow && this.movestate == 'down')    {        this.motionVec = null;    }    if (eventData.keysUp.uparrow && this.movestate == 'left')    {        this.motionVec = null;    }    if (eventData.keysUp.downarrow && this.movestate == 'right')    {        this.motionVec = null;    }}</pre></code><div><h6>7. </h6><p>That's it for the player. Deselect the player object, then click in the main 3D window. Use the arrow keys on the keyboard. You should see the player move!</p></div><p class='note'><em>Note: </em>The movement directions may appear wrong, as if the keys are mapped the wrong way. Don't worry about this - it depends on the camera orientation. In part 4, we'll be sure to make a camera that looks in the right direction, so the keys seem to work properly.</p><div><h6>8. </h6><p>Now, we need to create an object to hold some additional logic. This is the object that will check for the intersection of the player and to food, and make the food disappear. It will also monitor for when the game is complete. Use the skills you have learned above, and create a new box. Name it <em>GameManager</em>, and add the following code as its '<em>tick' </em>method.</p></div><pre><code>function tick(){    if (!this.pacman)        this.pacman = this.Scene.children_by_name.Player;    if (!this.piplist)    {        this.piplist = [];        for (var i = 0; i < this.Scene.children.length; i++)        {            if (this.Scene.children[i].gametype == 'food')            {                this.piplist.push(                {                    pip: this.Scene.children[i],                    pos: this.Scene.children[i].transformAPI.getPosition()                });                this.Scene.children[i].visible = true;            }        }        console.log(this.piplist);    }    var playerpos = this.pacman.transformAPI.getPosition();    var activecount = this.piplist.length;    for (var i = 0; i < this.piplist.length; i++)    {        var pip = this.piplist[i].pip;        if (pip.visible == true)        {            var pos = this.piplist[i].pos;            if (Vec3.distanceSquared(playerpos, pos) < .25)            {                pip.visible = false;            }        }        else        {            activecount--;        }    }    if (activecount == 0)    {        alertify.alert('You win!');        this.reset();    }}</pre></code><div><h6>9. </h6><p>Now, when you move across a food object, it will disappear. Move around and collect all the food!</p></div><div><h6>10. </h6><p>We still need a way to reset the game. Go to the '<em>Events' </em>tab of the script editor, and find the '<em>New Event' </em>button. Click it, and when prompted, type '<em>reset'</em>.</p></div><img src='images\Image40.png' /><div><h6>11. </h6><p>When prompted for the number of parameters, just leave the value at 0 and click <em>OK. </em>Paste the code below into the script window for the reset event.</p></div><pre><code>function reset(){    delete this.piplist;    this.Scene.children_by_name.Ghost.transformAPI.setPosition(4, -17, .5);    this.Scene.children_by_name.Player.transformAPI.setPosition(-2, -10, .5);   }</pre></code><div><h6>12. </h6><p>Save the event code with the button labeled 'Save Event'. Now, clicking the 'Trigger Event' button will reset the game. Note that the exact values used above depend on the exact setup of your level.</p></div><p class='remember'><em>Remember: </em>You can find the proper values for your level by selecting the Ghost or the player, and reading the translation out of the property editor.</p><img src='images\Image41.png' /><div><h6>13. </h6><p>Finally, we just need to add the code to make the Ghost work. Use the code below, but notice where I've added a note. This value should be the same value you used above - the default position for the player. Select the Ghost object, open the script editor, create a tick method, and paste in the code below.</p></div><pre><code>function tick(){    if (window.paused) return;    if (!this.pacman)        this.pacman = this.Scene.children_by_name.Player;    if (!this.pacman) return;    var random = Math.random() * 2000;    if (random > 0 && random < 10)    {        this.motionVec = [0, .5, 0];    }    if (random > 10 && random < 20)    {        this.motionVec = [0, -.5, 0];    }    if (random > 20 && random < 30)    {        this.motionVec = [.5, 0, 0];    }    if (random > 30 && random < 40)    {        this.motionVec = [-.5, 0, 0];    }    var oldpos = this.transformAPI.getPosition();    oldpos[0] = Math.floor(oldpos[0] * 2) / 2;    oldpos[1] = Math.floor(oldpos[1] * 2) / 2;    oldpos[2] = Math.floor(oldpos[2] * 2) / 2;    this.transformAPI.setPosition(oldpos);    if (Vec3.distance(oldpos, this.pacman.transformAPI.getPosition()) < 1.3)    {        alertify.log('Got you!');        this.pacman.transformAPI.setPosition(-2, -10, .6);    }    if (this.motionVec)    {        this.transformAPI.move(this.motionVec, 'parent');        var hit = _SceneManager.SphereCast(this.transformAPI.getPosition(), .35,        {            ignore: [_Editor.findviewnode(this.id).children[0].children[0], _Editor.GetMoveGizmo()],            filter: function(n)            {                if (n.passable) return false;                return true;            }        });        if (hit && hit.length)        {            this.transformAPI.setPosition(oldpos);            var random = Math.random() * 40;            if (random > 0 && random < 10)            {                this.motionVec = [0, .5, 0];            }            if (random > 10 && random < 20)            {                this.motionVec = [0, -.5, 0];            }            if (random > 20 && random < 30)            {                this.motionVec = [.5, 0, 0];            }            if (random > 30 && random < 40)            {                this.motionVec = [-.5, 0, 0];            }        }    }}</pre></code><div><h6>14. </h6><p>Congratulations! That's it! The game now works, and just needs a bit of polish to be completely finished!</p></div><h2>Part 4: Finishing touches</h2><p>Great! At this point, our game basically works. The last thing we need to do is create a camera and publish the world. This is pretty easy stuff from here on out.</p><div><h6>1. </h6><p>First, let's create a camera object, so that the user of our game does not have to mess with positioning the camera. Use the drop down menu, and find <em>Create->Cameras->Perspective</em></p></div><img src='images\Image42.png' /><div><h6>2. </h6><p>When you click this, a camera object will be created at the center of your view. You should see a camera icon appear. If you don't, zoom closer, and make sure you are in selection mode. The icon should look like this:</p></div><img src='images\Image43.png' /><div><h6>3. </h6><p>This icon helps you select and place the camera. Click on the camera to select it. You'll see a preview appear in the lower left of the main window that shows you what the camera sees. Move the camera so that it points down at the game board. You'll also see a helpful graphic that shows you in the main view where the camera is pointing. Aim for something like this:</p></div><img src='images\Image44.png' /><div><h6>4. </h6><p>Let's enter the camera to see exactly what it sees. Find the <em>Camera->Activate Camera </em>item on the dropdown list.</p></div><img src='images\Image45.png' /><div><h6>5. </h6><p>When you click it, you'll see this prompt. Choose Camera1, and click ok.</p></div><img src='images\Image46.png' /><div><h6>6. </h6><p>You are now looking exactly out of the camera. Use the arrow keys to move the player. Does it seem to go in the right direction? If not, you might need to go back to the Editor Camera, and reposition the camera object. If you're happy with the camera's view, then we're all done inside the editor, and we can move on to publish our game.</p></div><p class='note'><em>Note: </em>You will probably need to rotate your camera - it really depends on how your level is laid out. Look for the rotate tool on the toolbar. This will switch the axis graphic to a series of rings. Click and drag the rings to rotate the selected object.</p><div><h6>7. </h6><p>Finally, before we leave the game, let's set the thumbnail that users will see on the main page. While looking out of your camera, use the dropdown menu item <em>File->Set World Thumbnail</em>. You should see a slight flicker in the main window. The exact image you see will now be the thumbnail for this world on the world's page.</p></div><img src='images\Image47.png' /><div><h6>8. </h6><p>Since we're done editing the game, let's leave this world. Use the Log out button in the upper left of the screen. Your game will be saved automatically.</p></div><img src='images\Image48.png' /><div><h6>9. </h6><p>Now, we need to find your world so we can publish it. Go to the Worlds page. Use the search box to search for your world. Since I named the world Tutorial Demo, I'll search 'Tut'</p></div><img src='images\Image49.png' /><div><h6>10. </h6><p>When you find your world, click the title or the thumbnail to get to the worlds landing page. If you are logged in, you should see an option to publish the world. Click the <em>Publish </em>button.</p></div><img src='images\Image50.png' /><p class='note'><em>Note: </em>You can change the publish settings in the future. If you need to keep editing, come back to the publish page, uncheck the publish button, then click publish. The world is now editable again.</p><div><h6>11. </h6><p>Now, we just have to set a few settings. First, check the '<em>Publish World' </em>checkbox. Since this is a single player game, check the '<em>Single Player' </em>checkbox as well. Be sure that "<em>Create and Avatar for each user</em>", "<em>Allow Editor Tools</em>", and "<em><em>Use Default Camera</em></em>" are unchecked. In the box that appears under "<em><em>Use Default Camera</em></em>" choose the name of your camera. You should have an option called '<em>Camera1'</em>.</p></div><img src='images\Image51.png' /><div><h6>12. </h6><p>Click the publish button! You're done! You now have a completely working game published on the VWS website. To play the game, just click on the world's title from the World's page to load it.</p></div><h2>Conclusion</h2><p>You can share this game with others by copying and emailing the direct link, or your friends can search for it on the worlds page. By the end of this tutorial, you should have a firm foundation for building more complex games in the future. Hopefully, you'll also get comfortable with the user interface of the VWS software, and start thinking of other things to create! Here are a few challenges that build on this lesson. Make 3 Ghosts. Make a bigger level. Make the food come back after a certain time. If you're feeling really ambitious, make the Ghost behave with more intelligence. There is literally an infinite amount of ideas for expanding this simple tutorial. Check out the appendix below for more info on how the code works, if you're interested in making a more complex game. You can play the finished (with a few improvements) game here: <a href='http://vwf.adlnet.gov/472/adl/sandbox/yU4EixCOyfp6RQaW/' >http://vwf.adlnet.gov/472/adl/sandbox/yU4EixCOyfp6RQaW/</a></p><h2>Appendix 1: Code explanation</h2><p>It's not absolutely necessary for you to understand what the code is doing in order to make the game work. However, if you do know a bit of JavaScript, you might want to expand on this tutorial to build a more complex game. In that case, I'm providing here some explanation for the code you see above. I'll break it down by each object's methods and events, and each major portion of each of those scripts.</p><p>The code for the <em>tick </em>method on the player object.</p><pre><code>function tick(){    if (this.motionVec)    {        var oldpos = this.transformAPI.getPosition();        this.transformAPI.move(this.motionVec, 'parent');        var hit = _SceneManager.SphereCast(this.transformAPI.getPosition(), .35,        {            ignore: [_Editor.findviewnode(this.id).children[0].children[0], _Editor.GetMoveGizmo()],            filter: function(n)            {                if (n.passable) return false;                return true;            }        });        if (hit && hit.length)        {                        this.transformAPI.setPosition(oldpos);        }    }}</pre></code><pre><code>function tick(){...}</pre></code><p>Below, we are just declaring the function. Its name, 'tick', is a special case name within the VWS system. Tick functions on objects are called 20 times a second. This is where you can change values over time to create motion or other animations.</p><pre><code>...if (this.motionVec)    {        var oldpos = this.transformAPI.getPosition();        this.transformAPI.move(this.motionVec, 'parent');......</pre></code><p>If <em>this</em> object (the <em><em>Player</em></em>), has a <em><em><em>motionVec </em></em></em>variable, then get and store the current object position in a variable called <em>oldpos</em>. Then move the object (<em><em>Player</em></em>) by the motion vector. So, if the <em><em>Player</em></em> is at [1,0,0], and <em><em><em>motionVec </em></em></em>is [1,0,0], make the new position of the player [2,0,0]. You can see how, by calling <em>this</em> at every tick, the value of the X coordinate of the player's position increases over time. This is the basic mechanism for moving the player. The <em>KeyDown </em>and <em>KeyUp </em>events control what the value of <em>this</em>.<em><em><em>motionVec </em></em></em>is.</p><pre><code>...var hit = _SceneManager.SphereCast(this.transformAPI.getPosition(), .35,        {            ignore: [_Editor.findviewnode(this.id).children[0].children[0], _Editor.GetMoveGizmo()],            filter: function(n)            {                if (n.passable) return false;                return true;            }        });...</pre></code><p>This is a much more interesting bit of code. It's what prevents the character from intersecting the walls. <em>_<em>SceneManager.<em>SphereCast </em></em></em>is a function that allows you to query the geometry of the world, to decide if any of the objects in the world intersect a sphere. The first parameter is the center of the sphere you would like to use to check for intersections. The second parameter, in this case .<em>35</em>, is the radius of the sphere. Notice how we are basically saying "Now that we've moved the player, does a sphere at his new position with a radius of .<em>35</em> interesect any of the world geometry?". <em>_<em>SceneManager.<em>SphereCast </em></em></em>also takes an options object as the final parameter. This object here contains a list of graphics objects to ignore - namely, the sphere itself, and the Axis control you've been using to move objects around. This is sort of a leaky abstraction - from game code, your objects should have no knoledge of the Axis "gizmo" that you use to move objects. We'll fix this in time. Also, eventaully you'll be able to ignore objects by the names you give them, rather than the ugly <em>_Editor.findviewnode(this.id).... </em>Because the <em>SphereCast </em>function operates over the graphic objects, it currently expects you to provide the actaul 3D sphere object from the graphics engine. <em>_Editor.findviewnode(this.id) </em>is how you access this (for now).</p><pre><code>if (hit && hit.length)        {                        this.transformAPI.setPosition(oldpos);        }</pre></code><p>This last bit is much easier. It just says "Well, if we did hit something, put the <em>Player </em>back where he was!" That's all there is to preventing intersections for this simple game.</p><p>The code for <em>keyDown</em></p><pre><code>function keyDown(eventData, nodeData){    if (eventData.keysDown.rightarrow)    {        this.motionVec = [0, -.5, 0];        this.movestate = 'up';    }    if (eventData.keysDown.leftarrow)    {        this.motionVec = [0, .5, 0];        this.movestate = 'down';    }    if (eventData.keysDown.uparrow)    {        this.motionVec = [.5, 0, 0];        this.movestate = 'left';    }    if (eventData.keysDown.downarrow)    {        this.motionVec = [-.5, 0, 0];        this.movestate = 'right';    }}</pre></code><p>This one is much simpler, and I won't spend too much time on it. The engine notifies your objects about user input events by calling the Event code you inserted in the Script Editor panel. Because we had the <em>Player </em>selected when we created the code above, '<em>this' </em>means the player. So, think about the code above in the <em>tick </em>section. You can see how the value of the player motion depends on the <em>motionVec</em>, and the value of <em>motionVec</em> is controlled by the <em>keyDown </em>events. We also track <em>this.movestate </em>just to make it easier to figure out what key is currently pressed. This information is also contained in the <em>motionVec</em> variable, but I've done it this way just for readability. I won't go into any detail on the keyUp code. It should be self explanatory.</p><p>The Ghost object is a very simple example of AI. It just randomly moves around the scene, and detects when it gets close to the player. Here is the total code for the Ghost. It's all located inside the objects tick method.</p><pre><code>if (window.paused) return;    if (!this.pacman)        this.pacman = this.Scene.children_by_name.Player;    if (!this.pacman) return;...</pre></code><p>In this first section, we just try to get a reference to the <em>player </em>object. If can't get one for some reason, we just end the code by calling <em>return</em>. Notice how we save the reference to the <em>player </em>in the variable <em>this.pacman</em>? Looking up the object by its name is a somewhat expensive operation. It makes much more sense to find it once and hold onto it in a variable, then to look it up each time.</p><pre><code>var random = Math.random() * 2000;    if (random > 0 && random < 10)    {        this.motionVec = [0, .5, 0];    }    if (random > 10 && random < 20)    {        this.motionVec = [0, -.5, 0];    }    if (random > 20 && random < 30)    {        this.motionVec = [.5, 0, 0];    }    if (random > 30 && random < 40)    {        this.motionVec = [-.5, 0, 0];    }</pre></code><p>The Ghost code will work a lot like the player code. Every frame, we move the object by some value. Because the Ghost does not accept keyboard inputs, it instead uses a random number. Here, we randomly choose a direction to move.</p><pre><code>var oldpos = this.transformAPI.getPosition();    oldpos[0] = Math.floor(oldpos[0] * 2) / 2;    oldpos[1] = Math.floor(oldpos[1] * 2) / 2;    oldpos[2] = Math.floor(oldpos[2] * 2) / 2;    this.transformAPI.setPosition(oldpos);</pre></code><p>This block of code is just some housekeeping. In this game, it's important that objects move in strait lines, and that they never end up with fractional positions, other then half steps between numbers. If the X position of the Ghost object is 1.34324343 or something like that, it can get stuck in walls. While the code normally does not allow the object to get into that sort of a state, this code just ensures it never happens. We read the position, clamp it to halfsteps with Math.floor, and write it back.</p><pre><code>if (Vec3.distance(oldpos, this.pacman.transformAPI.getPosition()) < 1.3)    {        alertify.log('Got you!');        this.pacman.transformAPI.setPosition(-2, -10, .6);    }</pre></code><p>This simple block of code is the code that checks if the player got too near the Ghost. We could have used SphereCast like above, but this is simpler and works just as well. When the player gets too close, we send the player back to the start position, and make a little popup that says 'Got you!'  Note that the value in the <em>setPosition </em>will depend on the layout of your level.</p><pre><code>if (this.motionVec)    {        this.transformAPI.move(this.motionVec, 'parent');        var hit = _SceneManager.SphereCast(this.transformAPI.getPosition(), .35,        {            ignore: [_Editor.findviewnode(this.id).children[0].children[0], _Editor.GetMoveGizmo()],            filter: function(n)            {                if (n.passable) return false;                return true;            }        });</pre></code><p>This is the code that moves the ghost, just like the player. The ghost moves the amount of his <em>motionVec</em>. We use the exact same collision detection code, filtering out the ghosts own polygons, and any polygons of passable objects.</p><pre><code>if (hit && hit.length){    var random = Math.random() * 40;    if (random > 0 && random < 10)    {        this.motionVec = [0, .5, 0];    }    if (random > 10 && random < 20)    {        this.motionVec = [0, -.5, 0];    }    if (random > 20 && random < 30)    {        this.motionVec = [.5, 0, 0];    }    if (random > 30 && random < 40)    {        this.motionVec = [-.5, 0, 0];    }</pre></code><p>This final bit of code is very similar to the first block that randomly changed the <em>motionVec</em>. The difference is that this code is in the block with if(hit). This means that the code will only execute when the object hits something. Notice how the random chance of changing the value is much higher. Since the ghost has hit an object, it must change direction!</p><p>Like the Ghost, the GameManager has only a tick method. However, unlike the Ghost, the GameManager is not all that interested in its own location or movement. Instead, we use the GameManager object to hold some global code that implements the game logic. The gamemanager also has the necessary code to reset the game implemented in an event call 'reset'</p><pre><code>if (!this.pacman)        this.pacman = this.Scene.children_by_name.Player;</pre></code><p>First, we just find and cache a reference to the player object. It's more efficient to cache this value then to find it at every tick.</p><pre><code>if (!this.piplist)    {        this.piplist = [];        for (var i = 0; i < this.Scene.children.length; i++)        {            if (this.Scene.children[i].gametype == 'food')            {                this.piplist.push(                {                    pip: this.Scene.children[i],                    pos: this.Scene.children[i].transformAPI.getPosition()                });                this.Scene.children[i].visible = true;            }        }    }</pre></code><p>This block of code is part of the setup of the game. Notice how it's surrounded by "<em>if(!this.piplist)". </em>So, if the object is not initialized with that value, we go ahead and set that value up. The <em>this.piplist </em>variable is an array that holds references to each food item in the scene, and the position of that object. We iterate over all the objects in the scene with "<em>for (var i = 0; i < this.Scene.children.length; i++)". </em>Notice how we next check each object to see if its '<em>gametype' </em>property is equal to '<em>food'</em>. You'll remember where we set this up in part 2. When you copied all the copies of the food object, this property copied as well. That's how we can check to see if each object is a food object, or something else like a wall. You'll also notice that this block of code caches the positions of each food inside of <em>this.piplist[i].pos. </em>Caching these values is efficient, because the objects never move! This block of code also sets each food object back to visible.</p><pre><code>var playerpos = this.pacman.transformAPI.getPosition();    var activecount = this.piplist.length;</pre></code><p>Here, we simply get the current position of the player, and the total number of food objects.</p><pre><code>for (var i = 0; i < this.piplist.length; i++)    {        var pip = this.piplist[i].pip;        if (pip.visible == true)        {            var pos = this.piplist[i].pos;            if (Vec3.distanceSquared(playerpos, pos) < .25)            {                pip.visible = false;            }        }        else        {            activecount--;        }    }</pre></code><p>Here is the real meat of the goal of the game. Loop over every bit of food. If that food is visible, and if the distance from the food to the player is less than .25, make the food object invisible by calling .<em>visible=false</em>; If the food is not visible, just subtract 1 from the total count. So, after this loop has run, <em>activecount </em>tells us how much food is still not eaten. What do we do with that?</p><pre><code>if (activecount == 0)    {        alertify.alert('You win!');        this.reset();    }</pre></code><p>It's as simple as that. If there is not more active food (food which is visible, then we show a message, and <em>reset </em>the game. <em>This.reset() </em>triggers the <em>reset </em>event.</p><pre><code>function reset(){    delete this.piplist;    this.Scene.children_by_name.Ghost.transformAPI.setPosition(4, -17, .5);    this.Scene.children_by_name.Player.transformAPI.setPosition(-2, -10, .5);}</pre></code><p>In the <em>reset </em>function, we just place the ghost and player back at their staring positions, and delete the list of food. Remember that, at the next tick, if the GameManager does not have a list of food, it will create that list, and make all the food visible.</p><p class='note'><em>Note: </em>The positions that the ghost and player need to be set to will differ in your level from these values.</p><h2>Appendix 2: About the VWS</h2><p>The Virtual World Sandbox is a project from Advanced Distributed Learning to bring game based training and scenario design to more people by building a completely HTML5, web based, multiuser simulation engine. The VWS application is built on top of the Virtual World Framework, a next generation simulation foundation. The VWS website is a demonstration site, and should be used for exploration and entertainment only. To setup your own server, check out the installation documents on github. You can learn more about the Virtual World Framework at <a href='http://www.virtualworldframework.com.' >http://www.virtualworldframework.com.</a> Contribute to the VWS project at <a href='https://github.com/adlnet/Sandbox.' >https://github.com/adlnet/Sandbox.</a> Send questions and comments to: Robert.chadwick.ctr@adlnet.gov. This tutorial was built with VWS version 0.4.7.2 on November 18, 2013.</p></div></body></html>